// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hardware.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hardware_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hardware_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hardware_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hardware_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hardware_2eproto;
namespace ashoka {
namespace hardware {
class AudioRequest;
class AudioRequestDefaultTypeInternal;
extern AudioRequestDefaultTypeInternal _AudioRequest_default_instance_;
class AudioRequest_File;
class AudioRequest_FileDefaultTypeInternal;
extern AudioRequest_FileDefaultTypeInternal _AudioRequest_File_default_instance_;
class AudioRequest_Stream;
class AudioRequest_StreamDefaultTypeInternal;
extern AudioRequest_StreamDefaultTypeInternal _AudioRequest_Stream_default_instance_;
class LedRequest;
class LedRequestDefaultTypeInternal;
extern LedRequestDefaultTypeInternal _LedRequest_default_instance_;
class Publisher;
class PublisherDefaultTypeInternal;
extern PublisherDefaultTypeInternal _Publisher_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class SmsRequest;
class SmsRequestDefaultTypeInternal;
extern SmsRequestDefaultTypeInternal _SmsRequest_default_instance_;
class SmsResponse;
class SmsResponseDefaultTypeInternal;
extern SmsResponseDefaultTypeInternal _SmsResponse_default_instance_;
class TtsRequest;
class TtsRequestDefaultTypeInternal;
extern TtsRequestDefaultTypeInternal _TtsRequest_default_instance_;
class TtyRequest;
class TtyRequestDefaultTypeInternal;
extern TtyRequestDefaultTypeInternal _TtyRequest_default_instance_;
class TtyResponse;
class TtyResponseDefaultTypeInternal;
extern TtyResponseDefaultTypeInternal _TtyResponse_default_instance_;
class VideoRequest;
class VideoRequestDefaultTypeInternal;
extern VideoRequestDefaultTypeInternal _VideoRequest_default_instance_;
class VideoRequest_File;
class VideoRequest_FileDefaultTypeInternal;
extern VideoRequest_FileDefaultTypeInternal _VideoRequest_File_default_instance_;
class VideoRequest_Stream;
class VideoRequest_StreamDefaultTypeInternal;
extern VideoRequest_StreamDefaultTypeInternal _VideoRequest_Stream_default_instance_;
}  // namespace hardware
}  // namespace ashoka
PROTOBUF_NAMESPACE_OPEN
template<> ::ashoka::hardware::AudioRequest* Arena::CreateMaybeMessage<::ashoka::hardware::AudioRequest>(Arena*);
template<> ::ashoka::hardware::AudioRequest_File* Arena::CreateMaybeMessage<::ashoka::hardware::AudioRequest_File>(Arena*);
template<> ::ashoka::hardware::AudioRequest_Stream* Arena::CreateMaybeMessage<::ashoka::hardware::AudioRequest_Stream>(Arena*);
template<> ::ashoka::hardware::LedRequest* Arena::CreateMaybeMessage<::ashoka::hardware::LedRequest>(Arena*);
template<> ::ashoka::hardware::Publisher* Arena::CreateMaybeMessage<::ashoka::hardware::Publisher>(Arena*);
template<> ::ashoka::hardware::Request* Arena::CreateMaybeMessage<::ashoka::hardware::Request>(Arena*);
template<> ::ashoka::hardware::Response* Arena::CreateMaybeMessage<::ashoka::hardware::Response>(Arena*);
template<> ::ashoka::hardware::SmsRequest* Arena::CreateMaybeMessage<::ashoka::hardware::SmsRequest>(Arena*);
template<> ::ashoka::hardware::SmsResponse* Arena::CreateMaybeMessage<::ashoka::hardware::SmsResponse>(Arena*);
template<> ::ashoka::hardware::TtsRequest* Arena::CreateMaybeMessage<::ashoka::hardware::TtsRequest>(Arena*);
template<> ::ashoka::hardware::TtyRequest* Arena::CreateMaybeMessage<::ashoka::hardware::TtyRequest>(Arena*);
template<> ::ashoka::hardware::TtyResponse* Arena::CreateMaybeMessage<::ashoka::hardware::TtyResponse>(Arena*);
template<> ::ashoka::hardware::VideoRequest* Arena::CreateMaybeMessage<::ashoka::hardware::VideoRequest>(Arena*);
template<> ::ashoka::hardware::VideoRequest_File* Arena::CreateMaybeMessage<::ashoka::hardware::VideoRequest_File>(Arena*);
template<> ::ashoka::hardware::VideoRequest_Stream* Arena::CreateMaybeMessage<::ashoka::hardware::VideoRequest_Stream>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ashoka {
namespace hardware {

enum TtsRequest_Locale : int {
  TtsRequest_Locale_English = 0,
  TtsRequest_Locale_Chinese = 1,
  TtsRequest_Locale_TtsRequest_Locale_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TtsRequest_Locale_TtsRequest_Locale_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TtsRequest_Locale_IsValid(int value);
constexpr TtsRequest_Locale TtsRequest_Locale_Locale_MIN = TtsRequest_Locale_English;
constexpr TtsRequest_Locale TtsRequest_Locale_Locale_MAX = TtsRequest_Locale_Chinese;
constexpr int TtsRequest_Locale_Locale_ARRAYSIZE = TtsRequest_Locale_Locale_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TtsRequest_Locale_descriptor();
template<typename T>
inline const std::string& TtsRequest_Locale_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TtsRequest_Locale>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TtsRequest_Locale_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TtsRequest_Locale_descriptor(), enum_t_value);
}
inline bool TtsRequest_Locale_Parse(
    const std::string& name, TtsRequest_Locale* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TtsRequest_Locale>(
    TtsRequest_Locale_descriptor(), name, value);
}
enum AudioRequest_Type : int {
  AudioRequest_Type_WAV = 0,
  AudioRequest_Type_MP3 = 1,
  AudioRequest_Type_AudioRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AudioRequest_Type_AudioRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AudioRequest_Type_IsValid(int value);
constexpr AudioRequest_Type AudioRequest_Type_Type_MIN = AudioRequest_Type_WAV;
constexpr AudioRequest_Type AudioRequest_Type_Type_MAX = AudioRequest_Type_MP3;
constexpr int AudioRequest_Type_Type_ARRAYSIZE = AudioRequest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioRequest_Type_descriptor();
template<typename T>
inline const std::string& AudioRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioRequest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioRequest_Type_descriptor(), enum_t_value);
}
inline bool AudioRequest_Type_Parse(
    const std::string& name, AudioRequest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioRequest_Type>(
    AudioRequest_Type_descriptor(), name, value);
}
enum VideoRequest_Type : int {
  VideoRequest_Type_MP4 = 0,
  VideoRequest_Type_VideoRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VideoRequest_Type_VideoRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VideoRequest_Type_IsValid(int value);
constexpr VideoRequest_Type VideoRequest_Type_Type_MIN = VideoRequest_Type_MP4;
constexpr VideoRequest_Type VideoRequest_Type_Type_MAX = VideoRequest_Type_MP4;
constexpr int VideoRequest_Type_Type_ARRAYSIZE = VideoRequest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoRequest_Type_descriptor();
template<typename T>
inline const std::string& VideoRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoRequest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VideoRequest_Type_descriptor(), enum_t_value);
}
inline bool VideoRequest_Type_Parse(
    const std::string& name, VideoRequest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoRequest_Type>(
    VideoRequest_Type_descriptor(), name, value);
}
// ===================================================================

class Request :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Request& default_instance();

  enum PayloadCase {
    kTty = 3,
    kLed = 4,
    kSms = 5,
    kAudio = 6,
    kVideo = 7,
    kTts = 8,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.Request";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTokenFieldNumber = 2,
    kTtyFieldNumber = 3,
    kLedFieldNumber = 4,
    kSmsFieldNumber = 5,
    kAudioFieldNumber = 6,
    kVideoFieldNumber = 7,
    kTtsFieldNumber = 8,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string token = 2;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // .ashoka.hardware.TtyRequest tty = 3;
  bool has_tty() const;
  private:
  bool _internal_has_tty() const;
  public:
  void clear_tty();
  const ::ashoka::hardware::TtyRequest& tty() const;
  ::ashoka::hardware::TtyRequest* release_tty();
  ::ashoka::hardware::TtyRequest* mutable_tty();
  void set_allocated_tty(::ashoka::hardware::TtyRequest* tty);
  private:
  const ::ashoka::hardware::TtyRequest& _internal_tty() const;
  ::ashoka::hardware::TtyRequest* _internal_mutable_tty();
  public:

  // .ashoka.hardware.LedRequest led = 4;
  bool has_led() const;
  private:
  bool _internal_has_led() const;
  public:
  void clear_led();
  const ::ashoka::hardware::LedRequest& led() const;
  ::ashoka::hardware::LedRequest* release_led();
  ::ashoka::hardware::LedRequest* mutable_led();
  void set_allocated_led(::ashoka::hardware::LedRequest* led);
  private:
  const ::ashoka::hardware::LedRequest& _internal_led() const;
  ::ashoka::hardware::LedRequest* _internal_mutable_led();
  public:

  // .ashoka.hardware.SmsRequest sms = 5;
  bool has_sms() const;
  private:
  bool _internal_has_sms() const;
  public:
  void clear_sms();
  const ::ashoka::hardware::SmsRequest& sms() const;
  ::ashoka::hardware::SmsRequest* release_sms();
  ::ashoka::hardware::SmsRequest* mutable_sms();
  void set_allocated_sms(::ashoka::hardware::SmsRequest* sms);
  private:
  const ::ashoka::hardware::SmsRequest& _internal_sms() const;
  ::ashoka::hardware::SmsRequest* _internal_mutable_sms();
  public:

  // .ashoka.hardware.AudioRequest audio = 6;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::ashoka::hardware::AudioRequest& audio() const;
  ::ashoka::hardware::AudioRequest* release_audio();
  ::ashoka::hardware::AudioRequest* mutable_audio();
  void set_allocated_audio(::ashoka::hardware::AudioRequest* audio);
  private:
  const ::ashoka::hardware::AudioRequest& _internal_audio() const;
  ::ashoka::hardware::AudioRequest* _internal_mutable_audio();
  public:

  // .ashoka.hardware.VideoRequest video = 7;
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::ashoka::hardware::VideoRequest& video() const;
  ::ashoka::hardware::VideoRequest* release_video();
  ::ashoka::hardware::VideoRequest* mutable_video();
  void set_allocated_video(::ashoka::hardware::VideoRequest* video);
  private:
  const ::ashoka::hardware::VideoRequest& _internal_video() const;
  ::ashoka::hardware::VideoRequest* _internal_mutable_video();
  public:

  // .ashoka.hardware.TtsRequest tts = 8;
  bool has_tts() const;
  private:
  bool _internal_has_tts() const;
  public:
  void clear_tts();
  const ::ashoka::hardware::TtsRequest& tts() const;
  ::ashoka::hardware::TtsRequest* release_tts();
  ::ashoka::hardware::TtsRequest* mutable_tts();
  void set_allocated_tts(::ashoka::hardware::TtsRequest* tts);
  private:
  const ::ashoka::hardware::TtsRequest& _internal_tts() const;
  ::ashoka::hardware::TtsRequest* _internal_mutable_tts();
  public:

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ashoka.hardware.Request)
 private:
  class _Internal;
  void set_has_tty();
  void set_has_led();
  void set_has_sms();
  void set_has_audio();
  void set_has_video();
  void set_has_tts();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  union PayloadUnion {
    PayloadUnion() {}
    ::ashoka::hardware::TtyRequest* tty_;
    ::ashoka::hardware::LedRequest* led_;
    ::ashoka::hardware::SmsRequest* sms_;
    ::ashoka::hardware::AudioRequest* audio_;
    ::ashoka::hardware::VideoRequest* video_;
    ::ashoka::hardware::TtsRequest* tts_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class Response :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Response& default_instance();

  enum PayloadCase {
    kEmpty = 3,
    kReason = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(nullptr);
  }

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.Response";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 2,
    kOkFieldNumber = 1,
    kEmptyFieldNumber = 3,
    kReasonFieldNumber = 4,
  };
  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // .google.protobuf.Empty empty = 3;
  bool has_empty() const;
  private:
  bool _internal_has_empty() const;
  public:
  void clear_empty();
  const PROTOBUF_NAMESPACE_ID::Empty& empty() const;
  PROTOBUF_NAMESPACE_ID::Empty* release_empty();
  PROTOBUF_NAMESPACE_ID::Empty* mutable_empty();
  void set_allocated_empty(PROTOBUF_NAMESPACE_ID::Empty* empty);
  private:
  const PROTOBUF_NAMESPACE_ID::Empty& _internal_empty() const;
  PROTOBUF_NAMESPACE_ID::Empty* _internal_mutable_empty();
  public:

  // string reason = 4;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  void set_reason(const std::string& value);
  void set_reason(std::string&& value);
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  std::string* mutable_reason();
  std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ashoka.hardware.Response)
 private:
  class _Internal;
  void set_has_empty();
  void set_has_reason();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  bool ok_;
  union PayloadUnion {
    PayloadUnion() {}
    PROTOBUF_NAMESPACE_ID::Empty* empty_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class Publisher :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.Publisher) */ {
 public:
  Publisher();
  virtual ~Publisher();

  Publisher(const Publisher& from);
  Publisher(Publisher&& from) noexcept
    : Publisher() {
    *this = ::std::move(from);
  }

  inline Publisher& operator=(const Publisher& from) {
    CopyFrom(from);
    return *this;
  }
  inline Publisher& operator=(Publisher&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Publisher& default_instance();

  enum PayloadCase {
    kTty = 2,
    kSms = 3,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Publisher* internal_default_instance() {
    return reinterpret_cast<const Publisher*>(
               &_Publisher_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Publisher& a, Publisher& b) {
    a.Swap(&b);
  }
  inline void Swap(Publisher* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Publisher* New() const final {
    return CreateMaybeMessage<Publisher>(nullptr);
  }

  Publisher* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Publisher>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Publisher& from);
  void MergeFrom(const Publisher& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Publisher* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.Publisher";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kTtyFieldNumber = 2,
    kSmsFieldNumber = 3,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:

  // .ashoka.hardware.TtyResponse tty = 2;
  bool has_tty() const;
  private:
  bool _internal_has_tty() const;
  public:
  void clear_tty();
  const ::ashoka::hardware::TtyResponse& tty() const;
  ::ashoka::hardware::TtyResponse* release_tty();
  ::ashoka::hardware::TtyResponse* mutable_tty();
  void set_allocated_tty(::ashoka::hardware::TtyResponse* tty);
  private:
  const ::ashoka::hardware::TtyResponse& _internal_tty() const;
  ::ashoka::hardware::TtyResponse* _internal_mutable_tty();
  public:

  // .ashoka.hardware.SmsResponse sms = 3;
  bool has_sms() const;
  private:
  bool _internal_has_sms() const;
  public:
  void clear_sms();
  const ::ashoka::hardware::SmsResponse& sms() const;
  ::ashoka::hardware::SmsResponse* release_sms();
  ::ashoka::hardware::SmsResponse* mutable_sms();
  void set_allocated_sms(::ashoka::hardware::SmsResponse* sms);
  private:
  const ::ashoka::hardware::SmsResponse& _internal_sms() const;
  ::ashoka::hardware::SmsResponse* _internal_mutable_sms();
  public:

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ashoka.hardware.Publisher)
 private:
  class _Internal;
  void set_has_tty();
  void set_has_sms();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  union PayloadUnion {
    PayloadUnion() {}
    ::ashoka::hardware::TtyResponse* tty_;
    ::ashoka::hardware::SmsResponse* sms_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class TtyRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.TtyRequest) */ {
 public:
  TtyRequest();
  virtual ~TtyRequest();

  TtyRequest(const TtyRequest& from);
  TtyRequest(TtyRequest&& from) noexcept
    : TtyRequest() {
    *this = ::std::move(from);
  }

  inline TtyRequest& operator=(const TtyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TtyRequest& operator=(TtyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TtyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TtyRequest* internal_default_instance() {
    return reinterpret_cast<const TtyRequest*>(
               &_TtyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TtyRequest& a, TtyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TtyRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TtyRequest* New() const final {
    return CreateMaybeMessage<TtyRequest>(nullptr);
  }

  TtyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TtyRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TtyRequest& from);
  void MergeFrom(const TtyRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TtyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.TtyRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // string command = 1;
  void clear_command();
  const std::string& command() const;
  void set_command(const std::string& value);
  void set_command(std::string&& value);
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  std::string* mutable_command();
  std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.TtyRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class TtyResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.TtyResponse) */ {
 public:
  TtyResponse();
  virtual ~TtyResponse();

  TtyResponse(const TtyResponse& from);
  TtyResponse(TtyResponse&& from) noexcept
    : TtyResponse() {
    *this = ::std::move(from);
  }

  inline TtyResponse& operator=(const TtyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TtyResponse& operator=(TtyResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TtyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TtyResponse* internal_default_instance() {
    return reinterpret_cast<const TtyResponse*>(
               &_TtyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TtyResponse& a, TtyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TtyResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TtyResponse* New() const final {
    return CreateMaybeMessage<TtyResponse>(nullptr);
  }

  TtyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TtyResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TtyResponse& from);
  void MergeFrom(const TtyResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TtyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.TtyResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.TtyResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class SmsRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.SmsRequest) */ {
 public:
  SmsRequest();
  virtual ~SmsRequest();

  SmsRequest(const SmsRequest& from);
  SmsRequest(SmsRequest&& from) noexcept
    : SmsRequest() {
    *this = ::std::move(from);
  }

  inline SmsRequest& operator=(const SmsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmsRequest& operator=(SmsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SmsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmsRequest* internal_default_instance() {
    return reinterpret_cast<const SmsRequest*>(
               &_SmsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SmsRequest& a, SmsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SmsRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SmsRequest* New() const final {
    return CreateMaybeMessage<SmsRequest>(nullptr);
  }

  SmsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SmsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SmsRequest& from);
  void MergeFrom(const SmsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.SmsRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhonesFieldNumber = 1,
    kMessagesFieldNumber = 2,
  };
  // repeated string phones = 1;
  int phones_size() const;
  private:
  int _internal_phones_size() const;
  public:
  void clear_phones();
  const std::string& phones(int index) const;
  std::string* mutable_phones(int index);
  void set_phones(int index, const std::string& value);
  void set_phones(int index, std::string&& value);
  void set_phones(int index, const char* value);
  void set_phones(int index, const char* value, size_t size);
  std::string* add_phones();
  void add_phones(const std::string& value);
  void add_phones(std::string&& value);
  void add_phones(const char* value);
  void add_phones(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& phones() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_phones();
  private:
  const std::string& _internal_phones(int index) const;
  std::string* _internal_add_phones();
  public:

  // repeated string messages = 2;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  const std::string& messages(int index) const;
  std::string* mutable_messages(int index);
  void set_messages(int index, const std::string& value);
  void set_messages(int index, std::string&& value);
  void set_messages(int index, const char* value);
  void set_messages(int index, const char* value, size_t size);
  std::string* add_messages();
  void add_messages(const std::string& value);
  void add_messages(std::string&& value);
  void add_messages(const char* value);
  void add_messages(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& messages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_messages();
  private:
  const std::string& _internal_messages(int index) const;
  std::string* _internal_add_messages();
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.SmsRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> phones_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> messages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class SmsResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.SmsResponse) */ {
 public:
  SmsResponse();
  virtual ~SmsResponse();

  SmsResponse(const SmsResponse& from);
  SmsResponse(SmsResponse&& from) noexcept
    : SmsResponse() {
    *this = ::std::move(from);
  }

  inline SmsResponse& operator=(const SmsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SmsResponse& operator=(SmsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SmsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SmsResponse* internal_default_instance() {
    return reinterpret_cast<const SmsResponse*>(
               &_SmsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SmsResponse& a, SmsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SmsResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SmsResponse* New() const final {
    return CreateMaybeMessage<SmsResponse>(nullptr);
  }

  SmsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SmsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SmsResponse& from);
  void MergeFrom(const SmsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SmsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.SmsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string phone = 1;
  void clear_phone();
  const std::string& phone() const;
  void set_phone(const std::string& value);
  void set_phone(std::string&& value);
  void set_phone(const char* value);
  void set_phone(const char* value, size_t size);
  std::string* mutable_phone();
  std::string* release_phone();
  void set_allocated_phone(std::string* phone);
  private:
  const std::string& _internal_phone() const;
  void _internal_set_phone(const std::string& value);
  std::string* _internal_mutable_phone();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.SmsResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class LedRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.LedRequest) */ {
 public:
  LedRequest();
  virtual ~LedRequest();

  LedRequest(const LedRequest& from);
  LedRequest(LedRequest&& from) noexcept
    : LedRequest() {
    *this = ::std::move(from);
  }

  inline LedRequest& operator=(const LedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LedRequest& operator=(LedRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedRequest* internal_default_instance() {
    return reinterpret_cast<const LedRequest*>(
               &_LedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LedRequest& a, LedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LedRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LedRequest* New() const final {
    return CreateMaybeMessage<LedRequest>(nullptr);
  }

  LedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LedRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LedRequest& from);
  void MergeFrom(const LedRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.LedRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnFieldNumber = 1,
    kOffFieldNumber = 2,
    kTimesFieldNumber = 3,
  };
  // uint32 on = 1;
  void clear_on();
  ::PROTOBUF_NAMESPACE_ID::uint32 on() const;
  void set_on(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_on() const;
  void _internal_set_on(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 off = 2;
  void clear_off();
  ::PROTOBUF_NAMESPACE_ID::uint32 off() const;
  void set_off(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_off() const;
  void _internal_set_off(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint64 times = 3;
  void clear_times();
  ::PROTOBUF_NAMESPACE_ID::uint64 times() const;
  void set_times(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_times() const;
  void _internal_set_times(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.LedRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 on_;
  ::PROTOBUF_NAMESPACE_ID::uint32 off_;
  ::PROTOBUF_NAMESPACE_ID::uint64 times_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class TtsRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.TtsRequest) */ {
 public:
  TtsRequest();
  virtual ~TtsRequest();

  TtsRequest(const TtsRequest& from);
  TtsRequest(TtsRequest&& from) noexcept
    : TtsRequest() {
    *this = ::std::move(from);
  }

  inline TtsRequest& operator=(const TtsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TtsRequest& operator=(TtsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TtsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TtsRequest* internal_default_instance() {
    return reinterpret_cast<const TtsRequest*>(
               &_TtsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TtsRequest& a, TtsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TtsRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TtsRequest* New() const final {
    return CreateMaybeMessage<TtsRequest>(nullptr);
  }

  TtsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TtsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TtsRequest& from);
  void MergeFrom(const TtsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TtsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.TtsRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TtsRequest_Locale Locale;
  static constexpr Locale English =
    TtsRequest_Locale_English;
  static constexpr Locale Chinese =
    TtsRequest_Locale_Chinese;
  static inline bool Locale_IsValid(int value) {
    return TtsRequest_Locale_IsValid(value);
  }
  static constexpr Locale Locale_MIN =
    TtsRequest_Locale_Locale_MIN;
  static constexpr Locale Locale_MAX =
    TtsRequest_Locale_Locale_MAX;
  static constexpr int Locale_ARRAYSIZE =
    TtsRequest_Locale_Locale_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Locale_descriptor() {
    return TtsRequest_Locale_descriptor();
  }
  template<typename T>
  static inline const std::string& Locale_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Locale>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Locale_Name.");
    return TtsRequest_Locale_Name(enum_t_value);
  }
  static inline bool Locale_Parse(const std::string& name,
      Locale* value) {
    return TtsRequest_Locale_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kIntervalFieldNumber = 1,
    kTimesFieldNumber = 2,
    kLocaleFieldNumber = 4,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint32 interval = 1;
  void clear_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 interval() const;
  void set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_interval() const;
  void _internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 times = 2;
  void clear_times();
  ::PROTOBUF_NAMESPACE_ID::uint32 times() const;
  void set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_times() const;
  void _internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .ashoka.hardware.TtsRequest.Locale locale = 4;
  void clear_locale();
  ::ashoka::hardware::TtsRequest_Locale locale() const;
  void set_locale(::ashoka::hardware::TtsRequest_Locale value);
  private:
  ::ashoka::hardware::TtsRequest_Locale _internal_locale() const;
  void _internal_set_locale(::ashoka::hardware::TtsRequest_Locale value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.TtsRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint32 interval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 times_;
  int locale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class AudioRequest_Stream :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.AudioRequest.Stream) */ {
 public:
  AudioRequest_Stream();
  virtual ~AudioRequest_Stream();

  AudioRequest_Stream(const AudioRequest_Stream& from);
  AudioRequest_Stream(AudioRequest_Stream&& from) noexcept
    : AudioRequest_Stream() {
    *this = ::std::move(from);
  }

  inline AudioRequest_Stream& operator=(const AudioRequest_Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioRequest_Stream& operator=(AudioRequest_Stream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioRequest_Stream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioRequest_Stream* internal_default_instance() {
    return reinterpret_cast<const AudioRequest_Stream*>(
               &_AudioRequest_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AudioRequest_Stream& a, AudioRequest_Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioRequest_Stream* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioRequest_Stream* New() const final {
    return CreateMaybeMessage<AudioRequest_Stream>(nullptr);
  }

  AudioRequest_Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioRequest_Stream>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioRequest_Stream& from);
  void MergeFrom(const AudioRequest_Stream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioRequest_Stream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.AudioRequest.Stream";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kOrderFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  void set_payload(const std::string& value);
  void set_payload(std::string&& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  std::string* mutable_payload();
  std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // int32 order = 1;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::int32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_order() const;
  void _internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .ashoka.hardware.AudioRequest.Type type = 2;
  void clear_type();
  ::ashoka::hardware::AudioRequest_Type type() const;
  void set_type(::ashoka::hardware::AudioRequest_Type value);
  private:
  ::ashoka::hardware::AudioRequest_Type _internal_type() const;
  void _internal_set_type(::ashoka::hardware::AudioRequest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.AudioRequest.Stream)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::int32 order_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class AudioRequest_File :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.AudioRequest.File) */ {
 public:
  AudioRequest_File();
  virtual ~AudioRequest_File();

  AudioRequest_File(const AudioRequest_File& from);
  AudioRequest_File(AudioRequest_File&& from) noexcept
    : AudioRequest_File() {
    *this = ::std::move(from);
  }

  inline AudioRequest_File& operator=(const AudioRequest_File& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioRequest_File& operator=(AudioRequest_File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioRequest_File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioRequest_File* internal_default_instance() {
    return reinterpret_cast<const AudioRequest_File*>(
               &_AudioRequest_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AudioRequest_File& a, AudioRequest_File& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioRequest_File* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioRequest_File* New() const final {
    return CreateMaybeMessage<AudioRequest_File>(nullptr);
  }

  AudioRequest_File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioRequest_File>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioRequest_File& from);
  void MergeFrom(const AudioRequest_File& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioRequest_File* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.AudioRequest.File";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kOrderFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 order = 1;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::int32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_order() const;
  void _internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.AudioRequest.File)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class AudioRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.AudioRequest) */ {
 public:
  AudioRequest();
  virtual ~AudioRequest();

  AudioRequest(const AudioRequest& from);
  AudioRequest(AudioRequest&& from) noexcept
    : AudioRequest() {
    *this = ::std::move(from);
  }

  inline AudioRequest& operator=(const AudioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioRequest& operator=(AudioRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioRequest* internal_default_instance() {
    return reinterpret_cast<const AudioRequest*>(
               &_AudioRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AudioRequest& a, AudioRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioRequest* New() const final {
    return CreateMaybeMessage<AudioRequest>(nullptr);
  }

  AudioRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioRequest& from);
  void MergeFrom(const AudioRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.AudioRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AudioRequest_Stream Stream;
  typedef AudioRequest_File File;

  typedef AudioRequest_Type Type;
  static constexpr Type WAV =
    AudioRequest_Type_WAV;
  static constexpr Type MP3 =
    AudioRequest_Type_MP3;
  static inline bool Type_IsValid(int value) {
    return AudioRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    AudioRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    AudioRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    AudioRequest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return AudioRequest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return AudioRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return AudioRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 3,
    kStreamsFieldNumber = 4,
    kIntervalFieldNumber = 1,
    kTimesFieldNumber = 2,
  };
  // repeated .ashoka.hardware.AudioRequest.File files = 3;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::ashoka::hardware::AudioRequest_File* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::AudioRequest_File >*
      mutable_files();
  private:
  const ::ashoka::hardware::AudioRequest_File& _internal_files(int index) const;
  ::ashoka::hardware::AudioRequest_File* _internal_add_files();
  public:
  const ::ashoka::hardware::AudioRequest_File& files(int index) const;
  ::ashoka::hardware::AudioRequest_File* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::AudioRequest_File >&
      files() const;

  // repeated .ashoka.hardware.AudioRequest.Stream streams = 4;
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  ::ashoka::hardware::AudioRequest_Stream* mutable_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::AudioRequest_Stream >*
      mutable_streams();
  private:
  const ::ashoka::hardware::AudioRequest_Stream& _internal_streams(int index) const;
  ::ashoka::hardware::AudioRequest_Stream* _internal_add_streams();
  public:
  const ::ashoka::hardware::AudioRequest_Stream& streams(int index) const;
  ::ashoka::hardware::AudioRequest_Stream* add_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::AudioRequest_Stream >&
      streams() const;

  // uint32 interval = 1;
  void clear_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 interval() const;
  void set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_interval() const;
  void _internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 times = 2;
  void clear_times();
  ::PROTOBUF_NAMESPACE_ID::uint32 times() const;
  void set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_times() const;
  void _internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.AudioRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::AudioRequest_File > files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::AudioRequest_Stream > streams_;
  ::PROTOBUF_NAMESPACE_ID::uint32 interval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 times_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class VideoRequest_Stream :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.VideoRequest.Stream) */ {
 public:
  VideoRequest_Stream();
  virtual ~VideoRequest_Stream();

  VideoRequest_Stream(const VideoRequest_Stream& from);
  VideoRequest_Stream(VideoRequest_Stream&& from) noexcept
    : VideoRequest_Stream() {
    *this = ::std::move(from);
  }

  inline VideoRequest_Stream& operator=(const VideoRequest_Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoRequest_Stream& operator=(VideoRequest_Stream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoRequest_Stream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoRequest_Stream* internal_default_instance() {
    return reinterpret_cast<const VideoRequest_Stream*>(
               &_VideoRequest_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VideoRequest_Stream& a, VideoRequest_Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoRequest_Stream* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoRequest_Stream* New() const final {
    return CreateMaybeMessage<VideoRequest_Stream>(nullptr);
  }

  VideoRequest_Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoRequest_Stream>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoRequest_Stream& from);
  void MergeFrom(const VideoRequest_Stream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoRequest_Stream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.VideoRequest.Stream";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kOrderFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  void set_payload(const std::string& value);
  void set_payload(std::string&& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  std::string* mutable_payload();
  std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // int32 order = 1;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::int32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_order() const;
  void _internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .ashoka.hardware.VideoRequest.Type type = 2;
  void clear_type();
  ::ashoka::hardware::VideoRequest_Type type() const;
  void set_type(::ashoka::hardware::VideoRequest_Type value);
  private:
  ::ashoka::hardware::VideoRequest_Type _internal_type() const;
  void _internal_set_type(::ashoka::hardware::VideoRequest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.VideoRequest.Stream)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::int32 order_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class VideoRequest_File :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.VideoRequest.File) */ {
 public:
  VideoRequest_File();
  virtual ~VideoRequest_File();

  VideoRequest_File(const VideoRequest_File& from);
  VideoRequest_File(VideoRequest_File&& from) noexcept
    : VideoRequest_File() {
    *this = ::std::move(from);
  }

  inline VideoRequest_File& operator=(const VideoRequest_File& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoRequest_File& operator=(VideoRequest_File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoRequest_File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoRequest_File* internal_default_instance() {
    return reinterpret_cast<const VideoRequest_File*>(
               &_VideoRequest_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VideoRequest_File& a, VideoRequest_File& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoRequest_File* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoRequest_File* New() const final {
    return CreateMaybeMessage<VideoRequest_File>(nullptr);
  }

  VideoRequest_File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoRequest_File>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoRequest_File& from);
  void MergeFrom(const VideoRequest_File& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoRequest_File* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.VideoRequest.File";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kOrderFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 order = 1;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::int32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_order() const;
  void _internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.VideoRequest.File)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class VideoRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.VideoRequest) */ {
 public:
  VideoRequest();
  virtual ~VideoRequest();

  VideoRequest(const VideoRequest& from);
  VideoRequest(VideoRequest&& from) noexcept
    : VideoRequest() {
    *this = ::std::move(from);
  }

  inline VideoRequest& operator=(const VideoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoRequest& operator=(VideoRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoRequest* internal_default_instance() {
    return reinterpret_cast<const VideoRequest*>(
               &_VideoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VideoRequest& a, VideoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoRequest* New() const final {
    return CreateMaybeMessage<VideoRequest>(nullptr);
  }

  VideoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoRequest& from);
  void MergeFrom(const VideoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.VideoRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VideoRequest_Stream Stream;
  typedef VideoRequest_File File;

  typedef VideoRequest_Type Type;
  static constexpr Type MP4 =
    VideoRequest_Type_MP4;
  static inline bool Type_IsValid(int value) {
    return VideoRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    VideoRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    VideoRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    VideoRequest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return VideoRequest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return VideoRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return VideoRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 3,
    kStreamsFieldNumber = 4,
    kIntervalFieldNumber = 1,
    kTimesFieldNumber = 2,
  };
  // repeated .ashoka.hardware.VideoRequest.File files = 3;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::ashoka::hardware::VideoRequest_File* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::VideoRequest_File >*
      mutable_files();
  private:
  const ::ashoka::hardware::VideoRequest_File& _internal_files(int index) const;
  ::ashoka::hardware::VideoRequest_File* _internal_add_files();
  public:
  const ::ashoka::hardware::VideoRequest_File& files(int index) const;
  ::ashoka::hardware::VideoRequest_File* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::VideoRequest_File >&
      files() const;

  // repeated .ashoka.hardware.VideoRequest.Stream streams = 4;
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  ::ashoka::hardware::VideoRequest_Stream* mutable_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::VideoRequest_Stream >*
      mutable_streams();
  private:
  const ::ashoka::hardware::VideoRequest_Stream& _internal_streams(int index) const;
  ::ashoka::hardware::VideoRequest_Stream* _internal_add_streams();
  public:
  const ::ashoka::hardware::VideoRequest_Stream& streams(int index) const;
  ::ashoka::hardware::VideoRequest_Stream* add_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::VideoRequest_Stream >&
      streams() const;

  // uint32 interval = 1;
  void clear_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 interval() const;
  void set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_interval() const;
  void _internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 times = 2;
  void clear_times();
  ::PROTOBUF_NAMESPACE_ID::uint32 times() const;
  void set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_times() const;
  void _internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.VideoRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::VideoRequest_File > files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::VideoRequest_Stream > streams_;
  ::PROTOBUF_NAMESPACE_ID::uint32 interval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 times_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// string id = 1;
inline void Request::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Request::id() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Request.id)
  return _internal_id();
}
inline void Request::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Request.id)
}
inline std::string* Request::mutable_id() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Request.id)
  return _internal_mutable_id();
}
inline const std::string& Request::_internal_id() const {
  return id_.GetNoArena();
}
inline void Request::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Request::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.Request.id)
}
inline void Request::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.Request.id)
}
inline void Request::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.Request.id)
}
inline std::string* Request::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Request::release_id() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Request.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.Request.id)
}

// string token = 2;
inline void Request::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Request::token() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Request.token)
  return _internal_token();
}
inline void Request::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Request.token)
}
inline std::string* Request::mutable_token() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Request.token)
  return _internal_mutable_token();
}
inline const std::string& Request::_internal_token() const {
  return token_.GetNoArena();
}
inline void Request::_internal_set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Request::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.Request.token)
}
inline void Request::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.Request.token)
}
inline void Request::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.Request.token)
}
inline std::string* Request::_internal_mutable_token() {
  
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Request::release_token() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Request.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.Request.token)
}

// .ashoka.hardware.TtyRequest tty = 3;
inline bool Request::_internal_has_tty() const {
  return payload_case() == kTty;
}
inline bool Request::has_tty() const {
  return _internal_has_tty();
}
inline void Request::set_has_tty() {
  _oneof_case_[0] = kTty;
}
inline void Request::clear_tty() {
  if (_internal_has_tty()) {
    delete payload_.tty_;
    clear_has_payload();
  }
}
inline ::ashoka::hardware::TtyRequest* Request::release_tty() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Request.tty)
  if (_internal_has_tty()) {
    clear_has_payload();
      ::ashoka::hardware::TtyRequest* temp = payload_.tty_;
    payload_.tty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ashoka::hardware::TtyRequest& Request::_internal_tty() const {
  return _internal_has_tty()
      ? *payload_.tty_
      : *reinterpret_cast< ::ashoka::hardware::TtyRequest*>(&::ashoka::hardware::_TtyRequest_default_instance_);
}
inline const ::ashoka::hardware::TtyRequest& Request::tty() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Request.tty)
  return _internal_tty();
}
inline ::ashoka::hardware::TtyRequest* Request::_internal_mutable_tty() {
  if (!_internal_has_tty()) {
    clear_payload();
    set_has_tty();
    payload_.tty_ = CreateMaybeMessage< ::ashoka::hardware::TtyRequest >(
        GetArenaNoVirtual());
  }
  return payload_.tty_;
}
inline ::ashoka::hardware::TtyRequest* Request::mutable_tty() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Request.tty)
  return _internal_mutable_tty();
}

// .ashoka.hardware.LedRequest led = 4;
inline bool Request::_internal_has_led() const {
  return payload_case() == kLed;
}
inline bool Request::has_led() const {
  return _internal_has_led();
}
inline void Request::set_has_led() {
  _oneof_case_[0] = kLed;
}
inline void Request::clear_led() {
  if (_internal_has_led()) {
    delete payload_.led_;
    clear_has_payload();
  }
}
inline ::ashoka::hardware::LedRequest* Request::release_led() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Request.led)
  if (_internal_has_led()) {
    clear_has_payload();
      ::ashoka::hardware::LedRequest* temp = payload_.led_;
    payload_.led_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ashoka::hardware::LedRequest& Request::_internal_led() const {
  return _internal_has_led()
      ? *payload_.led_
      : *reinterpret_cast< ::ashoka::hardware::LedRequest*>(&::ashoka::hardware::_LedRequest_default_instance_);
}
inline const ::ashoka::hardware::LedRequest& Request::led() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Request.led)
  return _internal_led();
}
inline ::ashoka::hardware::LedRequest* Request::_internal_mutable_led() {
  if (!_internal_has_led()) {
    clear_payload();
    set_has_led();
    payload_.led_ = CreateMaybeMessage< ::ashoka::hardware::LedRequest >(
        GetArenaNoVirtual());
  }
  return payload_.led_;
}
inline ::ashoka::hardware::LedRequest* Request::mutable_led() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Request.led)
  return _internal_mutable_led();
}

// .ashoka.hardware.SmsRequest sms = 5;
inline bool Request::_internal_has_sms() const {
  return payload_case() == kSms;
}
inline bool Request::has_sms() const {
  return _internal_has_sms();
}
inline void Request::set_has_sms() {
  _oneof_case_[0] = kSms;
}
inline void Request::clear_sms() {
  if (_internal_has_sms()) {
    delete payload_.sms_;
    clear_has_payload();
  }
}
inline ::ashoka::hardware::SmsRequest* Request::release_sms() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Request.sms)
  if (_internal_has_sms()) {
    clear_has_payload();
      ::ashoka::hardware::SmsRequest* temp = payload_.sms_;
    payload_.sms_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ashoka::hardware::SmsRequest& Request::_internal_sms() const {
  return _internal_has_sms()
      ? *payload_.sms_
      : *reinterpret_cast< ::ashoka::hardware::SmsRequest*>(&::ashoka::hardware::_SmsRequest_default_instance_);
}
inline const ::ashoka::hardware::SmsRequest& Request::sms() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Request.sms)
  return _internal_sms();
}
inline ::ashoka::hardware::SmsRequest* Request::_internal_mutable_sms() {
  if (!_internal_has_sms()) {
    clear_payload();
    set_has_sms();
    payload_.sms_ = CreateMaybeMessage< ::ashoka::hardware::SmsRequest >(
        GetArenaNoVirtual());
  }
  return payload_.sms_;
}
inline ::ashoka::hardware::SmsRequest* Request::mutable_sms() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Request.sms)
  return _internal_mutable_sms();
}

// .ashoka.hardware.AudioRequest audio = 6;
inline bool Request::_internal_has_audio() const {
  return payload_case() == kAudio;
}
inline bool Request::has_audio() const {
  return _internal_has_audio();
}
inline void Request::set_has_audio() {
  _oneof_case_[0] = kAudio;
}
inline void Request::clear_audio() {
  if (_internal_has_audio()) {
    delete payload_.audio_;
    clear_has_payload();
  }
}
inline ::ashoka::hardware::AudioRequest* Request::release_audio() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Request.audio)
  if (_internal_has_audio()) {
    clear_has_payload();
      ::ashoka::hardware::AudioRequest* temp = payload_.audio_;
    payload_.audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ashoka::hardware::AudioRequest& Request::_internal_audio() const {
  return _internal_has_audio()
      ? *payload_.audio_
      : *reinterpret_cast< ::ashoka::hardware::AudioRequest*>(&::ashoka::hardware::_AudioRequest_default_instance_);
}
inline const ::ashoka::hardware::AudioRequest& Request::audio() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Request.audio)
  return _internal_audio();
}
inline ::ashoka::hardware::AudioRequest* Request::_internal_mutable_audio() {
  if (!_internal_has_audio()) {
    clear_payload();
    set_has_audio();
    payload_.audio_ = CreateMaybeMessage< ::ashoka::hardware::AudioRequest >(
        GetArenaNoVirtual());
  }
  return payload_.audio_;
}
inline ::ashoka::hardware::AudioRequest* Request::mutable_audio() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Request.audio)
  return _internal_mutable_audio();
}

// .ashoka.hardware.VideoRequest video = 7;
inline bool Request::_internal_has_video() const {
  return payload_case() == kVideo;
}
inline bool Request::has_video() const {
  return _internal_has_video();
}
inline void Request::set_has_video() {
  _oneof_case_[0] = kVideo;
}
inline void Request::clear_video() {
  if (_internal_has_video()) {
    delete payload_.video_;
    clear_has_payload();
  }
}
inline ::ashoka::hardware::VideoRequest* Request::release_video() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Request.video)
  if (_internal_has_video()) {
    clear_has_payload();
      ::ashoka::hardware::VideoRequest* temp = payload_.video_;
    payload_.video_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ashoka::hardware::VideoRequest& Request::_internal_video() const {
  return _internal_has_video()
      ? *payload_.video_
      : *reinterpret_cast< ::ashoka::hardware::VideoRequest*>(&::ashoka::hardware::_VideoRequest_default_instance_);
}
inline const ::ashoka::hardware::VideoRequest& Request::video() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Request.video)
  return _internal_video();
}
inline ::ashoka::hardware::VideoRequest* Request::_internal_mutable_video() {
  if (!_internal_has_video()) {
    clear_payload();
    set_has_video();
    payload_.video_ = CreateMaybeMessage< ::ashoka::hardware::VideoRequest >(
        GetArenaNoVirtual());
  }
  return payload_.video_;
}
inline ::ashoka::hardware::VideoRequest* Request::mutable_video() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Request.video)
  return _internal_mutable_video();
}

// .ashoka.hardware.TtsRequest tts = 8;
inline bool Request::_internal_has_tts() const {
  return payload_case() == kTts;
}
inline bool Request::has_tts() const {
  return _internal_has_tts();
}
inline void Request::set_has_tts() {
  _oneof_case_[0] = kTts;
}
inline void Request::clear_tts() {
  if (_internal_has_tts()) {
    delete payload_.tts_;
    clear_has_payload();
  }
}
inline ::ashoka::hardware::TtsRequest* Request::release_tts() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Request.tts)
  if (_internal_has_tts()) {
    clear_has_payload();
      ::ashoka::hardware::TtsRequest* temp = payload_.tts_;
    payload_.tts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ashoka::hardware::TtsRequest& Request::_internal_tts() const {
  return _internal_has_tts()
      ? *payload_.tts_
      : *reinterpret_cast< ::ashoka::hardware::TtsRequest*>(&::ashoka::hardware::_TtsRequest_default_instance_);
}
inline const ::ashoka::hardware::TtsRequest& Request::tts() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Request.tts)
  return _internal_tts();
}
inline ::ashoka::hardware::TtsRequest* Request::_internal_mutable_tts() {
  if (!_internal_has_tts()) {
    clear_payload();
    set_has_tts();
    payload_.tts_ = CreateMaybeMessage< ::ashoka::hardware::TtsRequest >(
        GetArenaNoVirtual());
  }
  return payload_.tts_;
}
inline ::ashoka::hardware::TtsRequest* Request::mutable_tts() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Request.tts)
  return _internal_mutable_tts();
}

inline bool Request::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Request::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Request::PayloadCase Request::payload_case() const {
  return Request::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// bool ok = 1;
inline void Response::clear_ok() {
  ok_ = false;
}
inline bool Response::_internal_ok() const {
  return ok_;
}
inline bool Response::ok() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Response.ok)
  return _internal_ok();
}
inline void Response::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void Response::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Response.ok)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool Response::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Response::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Response::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Response::timestamp() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Response.timestamp)
  return _internal_timestamp();
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Response::release_timestamp() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Response.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Response::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Response::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Response.timestamp)
  return _internal_mutable_timestamp();
}
inline void Response::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.Response.timestamp)
}

// .google.protobuf.Empty empty = 3;
inline bool Response::_internal_has_empty() const {
  return payload_case() == kEmpty;
}
inline bool Response::has_empty() const {
  return _internal_has_empty();
}
inline void Response::set_has_empty() {
  _oneof_case_[0] = kEmpty;
}
inline PROTOBUF_NAMESPACE_ID::Empty* Response::release_empty() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Response.empty)
  if (_internal_has_empty()) {
    clear_has_payload();
      PROTOBUF_NAMESPACE_ID::Empty* temp = payload_.empty_;
    payload_.empty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const PROTOBUF_NAMESPACE_ID::Empty& Response::_internal_empty() const {
  return _internal_has_empty()
      ? *payload_.empty_
      : *reinterpret_cast< PROTOBUF_NAMESPACE_ID::Empty*>(&PROTOBUF_NAMESPACE_ID::_Empty_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Empty& Response::empty() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Response.empty)
  return _internal_empty();
}
inline PROTOBUF_NAMESPACE_ID::Empty* Response::_internal_mutable_empty() {
  if (!_internal_has_empty()) {
    clear_payload();
    set_has_empty();
    payload_.empty_ = CreateMaybeMessage< PROTOBUF_NAMESPACE_ID::Empty >(
        GetArenaNoVirtual());
  }
  return payload_.empty_;
}
inline PROTOBUF_NAMESPACE_ID::Empty* Response::mutable_empty() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Response.empty)
  return _internal_mutable_empty();
}

// string reason = 4;
inline bool Response::_internal_has_reason() const {
  return payload_case() == kReason;
}
inline void Response::set_has_reason() {
  _oneof_case_[0] = kReason;
}
inline void Response::clear_reason() {
  if (_internal_has_reason()) {
    payload_.reason_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_payload();
  }
}
inline const std::string& Response::reason() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Response.reason)
  return _internal_reason();
}
inline void Response::set_reason(const std::string& value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Response.reason)
}
inline std::string* Response::mutable_reason() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Response.reason)
  return _internal_mutable_reason();
}
inline const std::string& Response::_internal_reason() const {
  if (_internal_has_reason()) {
    return payload_.reason_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Response::_internal_set_reason(const std::string& value) {
  if (!_internal_has_reason()) {
    clear_payload();
    set_has_reason();
    payload_.reason_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Response::set_reason(std::string&& value) {
  // @@protoc_insertion_point(field_set:ashoka.hardware.Response.reason)
  if (!_internal_has_reason()) {
    clear_payload();
    set_has_reason();
    payload_.reason_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.Response.reason)
}
inline void Response::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_reason()) {
    clear_payload();
    set_has_reason();
    payload_.reason_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.Response.reason)
}
inline void Response::set_reason(const char* value, size_t size) {
  if (!_internal_has_reason()) {
    clear_payload();
    set_has_reason();
    payload_.reason_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.reason_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.Response.reason)
}
inline std::string* Response::_internal_mutable_reason() {
  if (!_internal_has_reason()) {
    clear_payload();
    set_has_reason();
    payload_.reason_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return payload_.reason_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Response::release_reason() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Response.reason)
  if (_internal_has_reason()) {
    clear_has_payload();
    return payload_.reason_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Response::set_allocated_reason(std::string* reason) {
  if (has_payload()) {
    clear_payload();
  }
  if (reason != nullptr) {
    set_has_reason();
    payload_.reason_.UnsafeSetDefault(reason);
  }
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.Response.reason)
}

inline bool Response::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Response::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Response::PayloadCase Response::payload_case() const {
  return Response::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Publisher

// .google.protobuf.Timestamp timestamp = 1;
inline bool Publisher::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Publisher::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Publisher::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Publisher::timestamp() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Publisher.timestamp)
  return _internal_timestamp();
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Publisher::release_timestamp() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Publisher.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Publisher::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Publisher::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Publisher.timestamp)
  return _internal_mutable_timestamp();
}
inline void Publisher::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.Publisher.timestamp)
}

// .ashoka.hardware.TtyResponse tty = 2;
inline bool Publisher::_internal_has_tty() const {
  return payload_case() == kTty;
}
inline bool Publisher::has_tty() const {
  return _internal_has_tty();
}
inline void Publisher::set_has_tty() {
  _oneof_case_[0] = kTty;
}
inline void Publisher::clear_tty() {
  if (_internal_has_tty()) {
    delete payload_.tty_;
    clear_has_payload();
  }
}
inline ::ashoka::hardware::TtyResponse* Publisher::release_tty() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Publisher.tty)
  if (_internal_has_tty()) {
    clear_has_payload();
      ::ashoka::hardware::TtyResponse* temp = payload_.tty_;
    payload_.tty_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ashoka::hardware::TtyResponse& Publisher::_internal_tty() const {
  return _internal_has_tty()
      ? *payload_.tty_
      : *reinterpret_cast< ::ashoka::hardware::TtyResponse*>(&::ashoka::hardware::_TtyResponse_default_instance_);
}
inline const ::ashoka::hardware::TtyResponse& Publisher::tty() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Publisher.tty)
  return _internal_tty();
}
inline ::ashoka::hardware::TtyResponse* Publisher::_internal_mutable_tty() {
  if (!_internal_has_tty()) {
    clear_payload();
    set_has_tty();
    payload_.tty_ = CreateMaybeMessage< ::ashoka::hardware::TtyResponse >(
        GetArenaNoVirtual());
  }
  return payload_.tty_;
}
inline ::ashoka::hardware::TtyResponse* Publisher::mutable_tty() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Publisher.tty)
  return _internal_mutable_tty();
}

// .ashoka.hardware.SmsResponse sms = 3;
inline bool Publisher::_internal_has_sms() const {
  return payload_case() == kSms;
}
inline bool Publisher::has_sms() const {
  return _internal_has_sms();
}
inline void Publisher::set_has_sms() {
  _oneof_case_[0] = kSms;
}
inline void Publisher::clear_sms() {
  if (_internal_has_sms()) {
    delete payload_.sms_;
    clear_has_payload();
  }
}
inline ::ashoka::hardware::SmsResponse* Publisher::release_sms() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Publisher.sms)
  if (_internal_has_sms()) {
    clear_has_payload();
      ::ashoka::hardware::SmsResponse* temp = payload_.sms_;
    payload_.sms_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ashoka::hardware::SmsResponse& Publisher::_internal_sms() const {
  return _internal_has_sms()
      ? *payload_.sms_
      : *reinterpret_cast< ::ashoka::hardware::SmsResponse*>(&::ashoka::hardware::_SmsResponse_default_instance_);
}
inline const ::ashoka::hardware::SmsResponse& Publisher::sms() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Publisher.sms)
  return _internal_sms();
}
inline ::ashoka::hardware::SmsResponse* Publisher::_internal_mutable_sms() {
  if (!_internal_has_sms()) {
    clear_payload();
    set_has_sms();
    payload_.sms_ = CreateMaybeMessage< ::ashoka::hardware::SmsResponse >(
        GetArenaNoVirtual());
  }
  return payload_.sms_;
}
inline ::ashoka::hardware::SmsResponse* Publisher::mutable_sms() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Publisher.sms)
  return _internal_mutable_sms();
}

inline bool Publisher::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Publisher::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Publisher::PayloadCase Publisher::payload_case() const {
  return Publisher::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TtyRequest

// string command = 1;
inline void TtyRequest::clear_command() {
  command_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TtyRequest::command() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtyRequest.command)
  return _internal_command();
}
inline void TtyRequest::set_command(const std::string& value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtyRequest.command)
}
inline std::string* TtyRequest::mutable_command() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.TtyRequest.command)
  return _internal_mutable_command();
}
inline const std::string& TtyRequest::_internal_command() const {
  return command_.GetNoArena();
}
inline void TtyRequest::_internal_set_command(const std::string& value) {
  
  command_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TtyRequest::set_command(std::string&& value) {
  
  command_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.TtyRequest.command)
}
inline void TtyRequest::set_command(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  command_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.TtyRequest.command)
}
inline void TtyRequest::set_command(const char* value, size_t size) {
  
  command_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.TtyRequest.command)
}
inline std::string* TtyRequest::_internal_mutable_command() {
  
  return command_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TtyRequest::release_command() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.TtyRequest.command)
  
  return command_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TtyRequest::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  command_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), command);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.TtyRequest.command)
}

// -------------------------------------------------------------------

// TtyResponse

// string message = 1;
inline void TtyResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TtyResponse::message() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtyResponse.message)
  return _internal_message();
}
inline void TtyResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtyResponse.message)
}
inline std::string* TtyResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.TtyResponse.message)
  return _internal_mutable_message();
}
inline const std::string& TtyResponse::_internal_message() const {
  return message_.GetNoArena();
}
inline void TtyResponse::_internal_set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TtyResponse::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.TtyResponse.message)
}
inline void TtyResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.TtyResponse.message)
}
inline void TtyResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.TtyResponse.message)
}
inline std::string* TtyResponse::_internal_mutable_message() {
  
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TtyResponse::release_message() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.TtyResponse.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TtyResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.TtyResponse.message)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool TtyResponse::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool TtyResponse::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& TtyResponse::_internal_timestamp() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& TtyResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtyResponse.timestamp)
  return _internal_timestamp();
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* TtyResponse::release_timestamp() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.TtyResponse.timestamp)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* TtyResponse::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  return timestamp_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* TtyResponse::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.TtyResponse.timestamp)
  return _internal_mutable_timestamp();
}
inline void TtyResponse::set_allocated_timestamp(PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.TtyResponse.timestamp)
}

// -------------------------------------------------------------------

// SmsRequest

// repeated string phones = 1;
inline int SmsRequest::_internal_phones_size() const {
  return phones_.size();
}
inline int SmsRequest::phones_size() const {
  return _internal_phones_size();
}
inline void SmsRequest::clear_phones() {
  phones_.Clear();
}
inline std::string* SmsRequest::add_phones() {
  // @@protoc_insertion_point(field_add_mutable:ashoka.hardware.SmsRequest.phones)
  return _internal_add_phones();
}
inline const std::string& SmsRequest::_internal_phones(int index) const {
  return phones_.Get(index);
}
inline const std::string& SmsRequest::phones(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.SmsRequest.phones)
  return _internal_phones(index);
}
inline std::string* SmsRequest::mutable_phones(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.SmsRequest.phones)
  return phones_.Mutable(index);
}
inline void SmsRequest::set_phones(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ashoka.hardware.SmsRequest.phones)
  phones_.Mutable(index)->assign(value);
}
inline void SmsRequest::set_phones(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ashoka.hardware.SmsRequest.phones)
  phones_.Mutable(index)->assign(std::move(value));
}
inline void SmsRequest::set_phones(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  phones_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.SmsRequest.phones)
}
inline void SmsRequest::set_phones(int index, const char* value, size_t size) {
  phones_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.SmsRequest.phones)
}
inline std::string* SmsRequest::_internal_add_phones() {
  return phones_.Add();
}
inline void SmsRequest::add_phones(const std::string& value) {
  phones_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ashoka.hardware.SmsRequest.phones)
}
inline void SmsRequest::add_phones(std::string&& value) {
  phones_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ashoka.hardware.SmsRequest.phones)
}
inline void SmsRequest::add_phones(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  phones_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ashoka.hardware.SmsRequest.phones)
}
inline void SmsRequest::add_phones(const char* value, size_t size) {
  phones_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ashoka.hardware.SmsRequest.phones)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SmsRequest::phones() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.SmsRequest.phones)
  return phones_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SmsRequest::mutable_phones() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.SmsRequest.phones)
  return &phones_;
}

// repeated string messages = 2;
inline int SmsRequest::_internal_messages_size() const {
  return messages_.size();
}
inline int SmsRequest::messages_size() const {
  return _internal_messages_size();
}
inline void SmsRequest::clear_messages() {
  messages_.Clear();
}
inline std::string* SmsRequest::add_messages() {
  // @@protoc_insertion_point(field_add_mutable:ashoka.hardware.SmsRequest.messages)
  return _internal_add_messages();
}
inline const std::string& SmsRequest::_internal_messages(int index) const {
  return messages_.Get(index);
}
inline const std::string& SmsRequest::messages(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.SmsRequest.messages)
  return _internal_messages(index);
}
inline std::string* SmsRequest::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.SmsRequest.messages)
  return messages_.Mutable(index);
}
inline void SmsRequest::set_messages(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ashoka.hardware.SmsRequest.messages)
  messages_.Mutable(index)->assign(value);
}
inline void SmsRequest::set_messages(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ashoka.hardware.SmsRequest.messages)
  messages_.Mutable(index)->assign(std::move(value));
}
inline void SmsRequest::set_messages(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  messages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.SmsRequest.messages)
}
inline void SmsRequest::set_messages(int index, const char* value, size_t size) {
  messages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.SmsRequest.messages)
}
inline std::string* SmsRequest::_internal_add_messages() {
  return messages_.Add();
}
inline void SmsRequest::add_messages(const std::string& value) {
  messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ashoka.hardware.SmsRequest.messages)
}
inline void SmsRequest::add_messages(std::string&& value) {
  messages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ashoka.hardware.SmsRequest.messages)
}
inline void SmsRequest::add_messages(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ashoka.hardware.SmsRequest.messages)
}
inline void SmsRequest::add_messages(const char* value, size_t size) {
  messages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ashoka.hardware.SmsRequest.messages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SmsRequest::messages() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.SmsRequest.messages)
  return messages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SmsRequest::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.SmsRequest.messages)
  return &messages_;
}

// -------------------------------------------------------------------

// SmsResponse

// string phone = 1;
inline void SmsResponse::clear_phone() {
  phone_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SmsResponse::phone() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.SmsResponse.phone)
  return _internal_phone();
}
inline void SmsResponse::set_phone(const std::string& value) {
  _internal_set_phone(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.SmsResponse.phone)
}
inline std::string* SmsResponse::mutable_phone() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.SmsResponse.phone)
  return _internal_mutable_phone();
}
inline const std::string& SmsResponse::_internal_phone() const {
  return phone_.GetNoArena();
}
inline void SmsResponse::_internal_set_phone(const std::string& value) {
  
  phone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SmsResponse::set_phone(std::string&& value) {
  
  phone_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.SmsResponse.phone)
}
inline void SmsResponse::set_phone(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  phone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.SmsResponse.phone)
}
inline void SmsResponse::set_phone(const char* value, size_t size) {
  
  phone_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.SmsResponse.phone)
}
inline std::string* SmsResponse::_internal_mutable_phone() {
  
  return phone_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SmsResponse::release_phone() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.SmsResponse.phone)
  
  return phone_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SmsResponse::set_allocated_phone(std::string* phone) {
  if (phone != nullptr) {
    
  } else {
    
  }
  phone_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phone);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.SmsResponse.phone)
}

// string message = 2;
inline void SmsResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& SmsResponse::message() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.SmsResponse.message)
  return _internal_message();
}
inline void SmsResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.SmsResponse.message)
}
inline std::string* SmsResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.SmsResponse.message)
  return _internal_mutable_message();
}
inline const std::string& SmsResponse::_internal_message() const {
  return message_.GetNoArena();
}
inline void SmsResponse::_internal_set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SmsResponse::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.SmsResponse.message)
}
inline void SmsResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.SmsResponse.message)
}
inline void SmsResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.SmsResponse.message)
}
inline std::string* SmsResponse::_internal_mutable_message() {
  
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SmsResponse::release_message() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.SmsResponse.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SmsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.SmsResponse.message)
}

// -------------------------------------------------------------------

// LedRequest

// uint32 on = 1;
inline void LedRequest::clear_on() {
  on_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LedRequest::_internal_on() const {
  return on_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LedRequest::on() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.LedRequest.on)
  return _internal_on();
}
inline void LedRequest::_internal_set_on(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  on_ = value;
}
inline void LedRequest::set_on(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_on(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.LedRequest.on)
}

// uint32 off = 2;
inline void LedRequest::clear_off() {
  off_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LedRequest::_internal_off() const {
  return off_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LedRequest::off() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.LedRequest.off)
  return _internal_off();
}
inline void LedRequest::_internal_set_off(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  off_ = value;
}
inline void LedRequest::set_off(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_off(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.LedRequest.off)
}

// uint64 times = 3;
inline void LedRequest::clear_times() {
  times_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LedRequest::_internal_times() const {
  return times_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LedRequest::times() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.LedRequest.times)
  return _internal_times();
}
inline void LedRequest::_internal_set_times(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  times_ = value;
}
inline void LedRequest::set_times(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_times(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.LedRequest.times)
}

// -------------------------------------------------------------------

// TtsRequest

// uint32 interval = 1;
inline void TtsRequest::clear_interval() {
  interval_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TtsRequest::_internal_interval() const {
  return interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TtsRequest::interval() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtsRequest.interval)
  return _internal_interval();
}
inline void TtsRequest::_internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  interval_ = value;
}
inline void TtsRequest::set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtsRequest.interval)
}

// uint32 times = 2;
inline void TtsRequest::clear_times() {
  times_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TtsRequest::_internal_times() const {
  return times_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TtsRequest::times() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtsRequest.times)
  return _internal_times();
}
inline void TtsRequest::_internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  times_ = value;
}
inline void TtsRequest::set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_times(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtsRequest.times)
}

// string message = 3;
inline void TtsRequest::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TtsRequest::message() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtsRequest.message)
  return _internal_message();
}
inline void TtsRequest::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtsRequest.message)
}
inline std::string* TtsRequest::mutable_message() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.TtsRequest.message)
  return _internal_mutable_message();
}
inline const std::string& TtsRequest::_internal_message() const {
  return message_.GetNoArena();
}
inline void TtsRequest::_internal_set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TtsRequest::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.TtsRequest.message)
}
inline void TtsRequest::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.TtsRequest.message)
}
inline void TtsRequest::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.TtsRequest.message)
}
inline std::string* TtsRequest::_internal_mutable_message() {
  
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TtsRequest::release_message() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.TtsRequest.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TtsRequest::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.TtsRequest.message)
}

// .ashoka.hardware.TtsRequest.Locale locale = 4;
inline void TtsRequest::clear_locale() {
  locale_ = 0;
}
inline ::ashoka::hardware::TtsRequest_Locale TtsRequest::_internal_locale() const {
  return static_cast< ::ashoka::hardware::TtsRequest_Locale >(locale_);
}
inline ::ashoka::hardware::TtsRequest_Locale TtsRequest::locale() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtsRequest.locale)
  return _internal_locale();
}
inline void TtsRequest::_internal_set_locale(::ashoka::hardware::TtsRequest_Locale value) {
  
  locale_ = value;
}
inline void TtsRequest::set_locale(::ashoka::hardware::TtsRequest_Locale value) {
  _internal_set_locale(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtsRequest.locale)
}

// -------------------------------------------------------------------

// AudioRequest_Stream

// int32 order = 1;
inline void AudioRequest_Stream::clear_order() {
  order_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioRequest_Stream::_internal_order() const {
  return order_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioRequest_Stream::order() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.AudioRequest.Stream.order)
  return _internal_order();
}
inline void AudioRequest_Stream::_internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  order_ = value;
}
inline void AudioRequest_Stream::set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.AudioRequest.Stream.order)
}

// .ashoka.hardware.AudioRequest.Type type = 2;
inline void AudioRequest_Stream::clear_type() {
  type_ = 0;
}
inline ::ashoka::hardware::AudioRequest_Type AudioRequest_Stream::_internal_type() const {
  return static_cast< ::ashoka::hardware::AudioRequest_Type >(type_);
}
inline ::ashoka::hardware::AudioRequest_Type AudioRequest_Stream::type() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.AudioRequest.Stream.type)
  return _internal_type();
}
inline void AudioRequest_Stream::_internal_set_type(::ashoka::hardware::AudioRequest_Type value) {
  
  type_ = value;
}
inline void AudioRequest_Stream::set_type(::ashoka::hardware::AudioRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.AudioRequest.Stream.type)
}

// bytes payload = 3;
inline void AudioRequest_Stream::clear_payload() {
  payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AudioRequest_Stream::payload() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.AudioRequest.Stream.payload)
  return _internal_payload();
}
inline void AudioRequest_Stream::set_payload(const std::string& value) {
  _internal_set_payload(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.AudioRequest.Stream.payload)
}
inline std::string* AudioRequest_Stream::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.AudioRequest.Stream.payload)
  return _internal_mutable_payload();
}
inline const std::string& AudioRequest_Stream::_internal_payload() const {
  return payload_.GetNoArena();
}
inline void AudioRequest_Stream::_internal_set_payload(const std::string& value) {
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AudioRequest_Stream::set_payload(std::string&& value) {
  
  payload_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.AudioRequest.Stream.payload)
}
inline void AudioRequest_Stream::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.AudioRequest.Stream.payload)
}
inline void AudioRequest_Stream::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.AudioRequest.Stream.payload)
}
inline std::string* AudioRequest_Stream::_internal_mutable_payload() {
  
  return payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AudioRequest_Stream::release_payload() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.AudioRequest.Stream.payload)
  
  return payload_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AudioRequest_Stream::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.AudioRequest.Stream.payload)
}

// -------------------------------------------------------------------

// AudioRequest_File

// int32 order = 1;
inline void AudioRequest_File::clear_order() {
  order_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioRequest_File::_internal_order() const {
  return order_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AudioRequest_File::order() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.AudioRequest.File.order)
  return _internal_order();
}
inline void AudioRequest_File::_internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  order_ = value;
}
inline void AudioRequest_File::set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.AudioRequest.File.order)
}

// string path = 2;
inline void AudioRequest_File::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AudioRequest_File::path() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.AudioRequest.File.path)
  return _internal_path();
}
inline void AudioRequest_File::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.AudioRequest.File.path)
}
inline std::string* AudioRequest_File::mutable_path() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.AudioRequest.File.path)
  return _internal_mutable_path();
}
inline const std::string& AudioRequest_File::_internal_path() const {
  return path_.GetNoArena();
}
inline void AudioRequest_File::_internal_set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AudioRequest_File::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.AudioRequest.File.path)
}
inline void AudioRequest_File::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.AudioRequest.File.path)
}
inline void AudioRequest_File::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.AudioRequest.File.path)
}
inline std::string* AudioRequest_File::_internal_mutable_path() {
  
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AudioRequest_File::release_path() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.AudioRequest.File.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AudioRequest_File::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.AudioRequest.File.path)
}

// -------------------------------------------------------------------

// AudioRequest

// uint32 interval = 1;
inline void AudioRequest::clear_interval() {
  interval_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioRequest::_internal_interval() const {
  return interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioRequest::interval() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.AudioRequest.interval)
  return _internal_interval();
}
inline void AudioRequest::_internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  interval_ = value;
}
inline void AudioRequest::set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.AudioRequest.interval)
}

// uint32 times = 2;
inline void AudioRequest::clear_times() {
  times_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioRequest::_internal_times() const {
  return times_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioRequest::times() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.AudioRequest.times)
  return _internal_times();
}
inline void AudioRequest::_internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  times_ = value;
}
inline void AudioRequest::set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_times(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.AudioRequest.times)
}

// repeated .ashoka.hardware.AudioRequest.File files = 3;
inline int AudioRequest::_internal_files_size() const {
  return files_.size();
}
inline int AudioRequest::files_size() const {
  return _internal_files_size();
}
inline void AudioRequest::clear_files() {
  files_.Clear();
}
inline ::ashoka::hardware::AudioRequest_File* AudioRequest::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.AudioRequest.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::AudioRequest_File >*
AudioRequest::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.AudioRequest.files)
  return &files_;
}
inline const ::ashoka::hardware::AudioRequest_File& AudioRequest::_internal_files(int index) const {
  return files_.Get(index);
}
inline const ::ashoka::hardware::AudioRequest_File& AudioRequest::files(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.AudioRequest.files)
  return _internal_files(index);
}
inline ::ashoka::hardware::AudioRequest_File* AudioRequest::_internal_add_files() {
  return files_.Add();
}
inline ::ashoka::hardware::AudioRequest_File* AudioRequest::add_files() {
  // @@protoc_insertion_point(field_add:ashoka.hardware.AudioRequest.files)
  return _internal_add_files();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::AudioRequest_File >&
AudioRequest::files() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.AudioRequest.files)
  return files_;
}

// repeated .ashoka.hardware.AudioRequest.Stream streams = 4;
inline int AudioRequest::_internal_streams_size() const {
  return streams_.size();
}
inline int AudioRequest::streams_size() const {
  return _internal_streams_size();
}
inline void AudioRequest::clear_streams() {
  streams_.Clear();
}
inline ::ashoka::hardware::AudioRequest_Stream* AudioRequest::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.AudioRequest.streams)
  return streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::AudioRequest_Stream >*
AudioRequest::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.AudioRequest.streams)
  return &streams_;
}
inline const ::ashoka::hardware::AudioRequest_Stream& AudioRequest::_internal_streams(int index) const {
  return streams_.Get(index);
}
inline const ::ashoka::hardware::AudioRequest_Stream& AudioRequest::streams(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.AudioRequest.streams)
  return _internal_streams(index);
}
inline ::ashoka::hardware::AudioRequest_Stream* AudioRequest::_internal_add_streams() {
  return streams_.Add();
}
inline ::ashoka::hardware::AudioRequest_Stream* AudioRequest::add_streams() {
  // @@protoc_insertion_point(field_add:ashoka.hardware.AudioRequest.streams)
  return _internal_add_streams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::AudioRequest_Stream >&
AudioRequest::streams() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.AudioRequest.streams)
  return streams_;
}

// -------------------------------------------------------------------

// VideoRequest_Stream

// int32 order = 1;
inline void VideoRequest_Stream::clear_order() {
  order_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoRequest_Stream::_internal_order() const {
  return order_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoRequest_Stream::order() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.VideoRequest.Stream.order)
  return _internal_order();
}
inline void VideoRequest_Stream::_internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  order_ = value;
}
inline void VideoRequest_Stream::set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.VideoRequest.Stream.order)
}

// .ashoka.hardware.VideoRequest.Type type = 2;
inline void VideoRequest_Stream::clear_type() {
  type_ = 0;
}
inline ::ashoka::hardware::VideoRequest_Type VideoRequest_Stream::_internal_type() const {
  return static_cast< ::ashoka::hardware::VideoRequest_Type >(type_);
}
inline ::ashoka::hardware::VideoRequest_Type VideoRequest_Stream::type() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.VideoRequest.Stream.type)
  return _internal_type();
}
inline void VideoRequest_Stream::_internal_set_type(::ashoka::hardware::VideoRequest_Type value) {
  
  type_ = value;
}
inline void VideoRequest_Stream::set_type(::ashoka::hardware::VideoRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.VideoRequest.Stream.type)
}

// bytes payload = 3;
inline void VideoRequest_Stream::clear_payload() {
  payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VideoRequest_Stream::payload() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.VideoRequest.Stream.payload)
  return _internal_payload();
}
inline void VideoRequest_Stream::set_payload(const std::string& value) {
  _internal_set_payload(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.VideoRequest.Stream.payload)
}
inline std::string* VideoRequest_Stream::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.VideoRequest.Stream.payload)
  return _internal_mutable_payload();
}
inline const std::string& VideoRequest_Stream::_internal_payload() const {
  return payload_.GetNoArena();
}
inline void VideoRequest_Stream::_internal_set_payload(const std::string& value) {
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void VideoRequest_Stream::set_payload(std::string&& value) {
  
  payload_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.VideoRequest.Stream.payload)
}
inline void VideoRequest_Stream::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.VideoRequest.Stream.payload)
}
inline void VideoRequest_Stream::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.VideoRequest.Stream.payload)
}
inline std::string* VideoRequest_Stream::_internal_mutable_payload() {
  
  return payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VideoRequest_Stream::release_payload() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.VideoRequest.Stream.payload)
  
  return payload_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VideoRequest_Stream::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.VideoRequest.Stream.payload)
}

// -------------------------------------------------------------------

// VideoRequest_File

// int32 order = 1;
inline void VideoRequest_File::clear_order() {
  order_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoRequest_File::_internal_order() const {
  return order_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoRequest_File::order() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.VideoRequest.File.order)
  return _internal_order();
}
inline void VideoRequest_File::_internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  order_ = value;
}
inline void VideoRequest_File::set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.VideoRequest.File.order)
}

// string path = 2;
inline void VideoRequest_File::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VideoRequest_File::path() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.VideoRequest.File.path)
  return _internal_path();
}
inline void VideoRequest_File::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.VideoRequest.File.path)
}
inline std::string* VideoRequest_File::mutable_path() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.VideoRequest.File.path)
  return _internal_mutable_path();
}
inline const std::string& VideoRequest_File::_internal_path() const {
  return path_.GetNoArena();
}
inline void VideoRequest_File::_internal_set_path(const std::string& value) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void VideoRequest_File::set_path(std::string&& value) {
  
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.VideoRequest.File.path)
}
inline void VideoRequest_File::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.VideoRequest.File.path)
}
inline void VideoRequest_File::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.VideoRequest.File.path)
}
inline std::string* VideoRequest_File::_internal_mutable_path() {
  
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VideoRequest_File::release_path() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.VideoRequest.File.path)
  
  return path_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VideoRequest_File::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.VideoRequest.File.path)
}

// -------------------------------------------------------------------

// VideoRequest

// uint32 interval = 1;
inline void VideoRequest::clear_interval() {
  interval_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoRequest::_internal_interval() const {
  return interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoRequest::interval() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.VideoRequest.interval)
  return _internal_interval();
}
inline void VideoRequest::_internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  interval_ = value;
}
inline void VideoRequest::set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.VideoRequest.interval)
}

// uint32 times = 2;
inline void VideoRequest::clear_times() {
  times_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoRequest::_internal_times() const {
  return times_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VideoRequest::times() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.VideoRequest.times)
  return _internal_times();
}
inline void VideoRequest::_internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  times_ = value;
}
inline void VideoRequest::set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_times(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.VideoRequest.times)
}

// repeated .ashoka.hardware.VideoRequest.File files = 3;
inline int VideoRequest::_internal_files_size() const {
  return files_.size();
}
inline int VideoRequest::files_size() const {
  return _internal_files_size();
}
inline void VideoRequest::clear_files() {
  files_.Clear();
}
inline ::ashoka::hardware::VideoRequest_File* VideoRequest::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.VideoRequest.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::VideoRequest_File >*
VideoRequest::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.VideoRequest.files)
  return &files_;
}
inline const ::ashoka::hardware::VideoRequest_File& VideoRequest::_internal_files(int index) const {
  return files_.Get(index);
}
inline const ::ashoka::hardware::VideoRequest_File& VideoRequest::files(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.VideoRequest.files)
  return _internal_files(index);
}
inline ::ashoka::hardware::VideoRequest_File* VideoRequest::_internal_add_files() {
  return files_.Add();
}
inline ::ashoka::hardware::VideoRequest_File* VideoRequest::add_files() {
  // @@protoc_insertion_point(field_add:ashoka.hardware.VideoRequest.files)
  return _internal_add_files();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::VideoRequest_File >&
VideoRequest::files() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.VideoRequest.files)
  return files_;
}

// repeated .ashoka.hardware.VideoRequest.Stream streams = 4;
inline int VideoRequest::_internal_streams_size() const {
  return streams_.size();
}
inline int VideoRequest::streams_size() const {
  return _internal_streams_size();
}
inline void VideoRequest::clear_streams() {
  streams_.Clear();
}
inline ::ashoka::hardware::VideoRequest_Stream* VideoRequest::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.VideoRequest.streams)
  return streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::VideoRequest_Stream >*
VideoRequest::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.VideoRequest.streams)
  return &streams_;
}
inline const ::ashoka::hardware::VideoRequest_Stream& VideoRequest::_internal_streams(int index) const {
  return streams_.Get(index);
}
inline const ::ashoka::hardware::VideoRequest_Stream& VideoRequest::streams(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.VideoRequest.streams)
  return _internal_streams(index);
}
inline ::ashoka::hardware::VideoRequest_Stream* VideoRequest::_internal_add_streams() {
  return streams_.Add();
}
inline ::ashoka::hardware::VideoRequest_Stream* VideoRequest::add_streams() {
  // @@protoc_insertion_point(field_add:ashoka.hardware.VideoRequest.streams)
  return _internal_add_streams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::VideoRequest_Stream >&
VideoRequest::streams() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.VideoRequest.streams)
  return streams_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hardware
}  // namespace ashoka

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ashoka::hardware::TtsRequest_Locale> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ashoka::hardware::TtsRequest_Locale>() {
  return ::ashoka::hardware::TtsRequest_Locale_descriptor();
}
template <> struct is_proto_enum< ::ashoka::hardware::AudioRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ashoka::hardware::AudioRequest_Type>() {
  return ::ashoka::hardware::AudioRequest_Type_descriptor();
}
template <> struct is_proto_enum< ::ashoka::hardware::VideoRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ashoka::hardware::VideoRequest_Type>() {
  return ::ashoka::hardware::VideoRequest_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hardware_2eproto
