// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hardware.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hardware_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hardware_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hardware_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hardware_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hardware_2eproto;
namespace ashoka {
namespace hardware {
class Audio;
class AudioDefaultTypeInternal;
extern AudioDefaultTypeInternal _Audio_default_instance_;
class Audio_File;
class Audio_FileDefaultTypeInternal;
extern Audio_FileDefaultTypeInternal _Audio_File_default_instance_;
class Audio_Stream;
class Audio_StreamDefaultTypeInternal;
extern Audio_StreamDefaultTypeInternal _Audio_Stream_default_instance_;
class LedRequest;
class LedRequestDefaultTypeInternal;
extern LedRequestDefaultTypeInternal _LedRequest_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class TtsRequest;
class TtsRequestDefaultTypeInternal;
extern TtsRequestDefaultTypeInternal _TtsRequest_default_instance_;
class TtyRequest;
class TtyRequestDefaultTypeInternal;
extern TtyRequestDefaultTypeInternal _TtyRequest_default_instance_;
class TtyResponse;
class TtyResponseDefaultTypeInternal;
extern TtyResponseDefaultTypeInternal _TtyResponse_default_instance_;
class Video;
class VideoDefaultTypeInternal;
extern VideoDefaultTypeInternal _Video_default_instance_;
class Video_File;
class Video_FileDefaultTypeInternal;
extern Video_FileDefaultTypeInternal _Video_File_default_instance_;
class Video_Stream;
class Video_StreamDefaultTypeInternal;
extern Video_StreamDefaultTypeInternal _Video_Stream_default_instance_;
}  // namespace hardware
}  // namespace ashoka
PROTOBUF_NAMESPACE_OPEN
template<> ::ashoka::hardware::Audio* Arena::CreateMaybeMessage<::ashoka::hardware::Audio>(Arena*);
template<> ::ashoka::hardware::Audio_File* Arena::CreateMaybeMessage<::ashoka::hardware::Audio_File>(Arena*);
template<> ::ashoka::hardware::Audio_Stream* Arena::CreateMaybeMessage<::ashoka::hardware::Audio_Stream>(Arena*);
template<> ::ashoka::hardware::LedRequest* Arena::CreateMaybeMessage<::ashoka::hardware::LedRequest>(Arena*);
template<> ::ashoka::hardware::Response* Arena::CreateMaybeMessage<::ashoka::hardware::Response>(Arena*);
template<> ::ashoka::hardware::TtsRequest* Arena::CreateMaybeMessage<::ashoka::hardware::TtsRequest>(Arena*);
template<> ::ashoka::hardware::TtyRequest* Arena::CreateMaybeMessage<::ashoka::hardware::TtyRequest>(Arena*);
template<> ::ashoka::hardware::TtyResponse* Arena::CreateMaybeMessage<::ashoka::hardware::TtyResponse>(Arena*);
template<> ::ashoka::hardware::Video* Arena::CreateMaybeMessage<::ashoka::hardware::Video>(Arena*);
template<> ::ashoka::hardware::Video_File* Arena::CreateMaybeMessage<::ashoka::hardware::Video_File>(Arena*);
template<> ::ashoka::hardware::Video_Stream* Arena::CreateMaybeMessage<::ashoka::hardware::Video_Stream>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ashoka {
namespace hardware {

enum TtsRequest_Locale : int {
  TtsRequest_Locale_English = 0,
  TtsRequest_Locale_Chinese = 1,
  TtsRequest_Locale_TtsRequest_Locale_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TtsRequest_Locale_TtsRequest_Locale_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TtsRequest_Locale_IsValid(int value);
constexpr TtsRequest_Locale TtsRequest_Locale_Locale_MIN = TtsRequest_Locale_English;
constexpr TtsRequest_Locale TtsRequest_Locale_Locale_MAX = TtsRequest_Locale_Chinese;
constexpr int TtsRequest_Locale_Locale_ARRAYSIZE = TtsRequest_Locale_Locale_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TtsRequest_Locale_descriptor();
template<typename T>
inline const std::string& TtsRequest_Locale_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TtsRequest_Locale>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TtsRequest_Locale_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TtsRequest_Locale_descriptor(), enum_t_value);
}
inline bool TtsRequest_Locale_Parse(
    const std::string& name, TtsRequest_Locale* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TtsRequest_Locale>(
    TtsRequest_Locale_descriptor(), name, value);
}
enum Audio_Stream_Type : int {
  Audio_Stream_Type_WAV = 0,
  Audio_Stream_Type_MP3 = 1,
  Audio_Stream_Type_Audio_Stream_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Audio_Stream_Type_Audio_Stream_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Audio_Stream_Type_IsValid(int value);
constexpr Audio_Stream_Type Audio_Stream_Type_Type_MIN = Audio_Stream_Type_WAV;
constexpr Audio_Stream_Type Audio_Stream_Type_Type_MAX = Audio_Stream_Type_MP3;
constexpr int Audio_Stream_Type_Type_ARRAYSIZE = Audio_Stream_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Audio_Stream_Type_descriptor();
template<typename T>
inline const std::string& Audio_Stream_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Audio_Stream_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Audio_Stream_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Audio_Stream_Type_descriptor(), enum_t_value);
}
inline bool Audio_Stream_Type_Parse(
    const std::string& name, Audio_Stream_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Audio_Stream_Type>(
    Audio_Stream_Type_descriptor(), name, value);
}
enum Video_Stream_Type : int {
  Video_Stream_Type_MP4 = 0,
  Video_Stream_Type_Video_Stream_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Video_Stream_Type_Video_Stream_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Video_Stream_Type_IsValid(int value);
constexpr Video_Stream_Type Video_Stream_Type_Type_MIN = Video_Stream_Type_MP4;
constexpr Video_Stream_Type Video_Stream_Type_Type_MAX = Video_Stream_Type_MP4;
constexpr int Video_Stream_Type_Type_ARRAYSIZE = Video_Stream_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Video_Stream_Type_descriptor();
template<typename T>
inline const std::string& Video_Stream_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Video_Stream_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Video_Stream_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Video_Stream_Type_descriptor(), enum_t_value);
}
inline bool Video_Stream_Type_Parse(
    const std::string& name, Video_Stream_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Video_Stream_Type>(
    Video_Stream_Type_descriptor(), name, value);
}
// ===================================================================

class Response PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.Response) */ {
 public:
  inline Response() : Response(nullptr) {};
  virtual ~Response();

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(nullptr);
  }

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // repeated string messages = 3;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  const std::string& messages(int index) const;
  std::string* mutable_messages(int index);
  void set_messages(int index, const std::string& value);
  void set_messages(int index, std::string&& value);
  void set_messages(int index, const char* value);
  void set_messages(int index, const char* value, size_t size);
  std::string* add_messages();
  void add_messages(const std::string& value);
  void add_messages(std::string&& value);
  void add_messages(const char* value);
  void add_messages(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& messages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_messages();
  private:
  const std::string& _internal_messages(int index) const;
  std::string* _internal_add_messages();
  public:

  // uint64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> messages_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class TtyRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.TtyRequest) */ {
 public:
  inline TtyRequest() : TtyRequest(nullptr) {};
  virtual ~TtyRequest();

  TtyRequest(const TtyRequest& from);
  TtyRequest(TtyRequest&& from) noexcept
    : TtyRequest() {
    *this = ::std::move(from);
  }

  inline TtyRequest& operator=(const TtyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TtyRequest& operator=(TtyRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TtyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TtyRequest* internal_default_instance() {
    return reinterpret_cast<const TtyRequest*>(
               &_TtyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TtyRequest& a, TtyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TtyRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TtyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TtyRequest* New() const final {
    return CreateMaybeMessage<TtyRequest>(nullptr);
  }

  TtyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TtyRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TtyRequest& from);
  void MergeFrom(const TtyRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TtyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.TtyRequest";
  }
  protected:
  explicit TtyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
  };
  // string command = 1;
  void clear_command();
  const std::string& command() const;
  void set_command(const std::string& value);
  void set_command(std::string&& value);
  void set_command(const char* value);
  void set_command(const char* value, size_t size);
  std::string* mutable_command();
  std::string* release_command();
  void set_allocated_command(std::string* command);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_command();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_command(
      std::string* command);
  private:
  const std::string& _internal_command() const;
  void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.TtyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class TtyResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.TtyResponse) */ {
 public:
  inline TtyResponse() : TtyResponse(nullptr) {};
  virtual ~TtyResponse();

  TtyResponse(const TtyResponse& from);
  TtyResponse(TtyResponse&& from) noexcept
    : TtyResponse() {
    *this = ::std::move(from);
  }

  inline TtyResponse& operator=(const TtyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TtyResponse& operator=(TtyResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TtyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TtyResponse* internal_default_instance() {
    return reinterpret_cast<const TtyResponse*>(
               &_TtyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TtyResponse& a, TtyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TtyResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TtyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TtyResponse* New() const final {
    return CreateMaybeMessage<TtyResponse>(nullptr);
  }

  TtyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TtyResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TtyResponse& from);
  void MergeFrom(const TtyResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TtyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.TtyResponse";
  }
  protected:
  explicit TtyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.TtyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class LedRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.LedRequest) */ {
 public:
  inline LedRequest() : LedRequest(nullptr) {};
  virtual ~LedRequest();

  LedRequest(const LedRequest& from);
  LedRequest(LedRequest&& from) noexcept
    : LedRequest() {
    *this = ::std::move(from);
  }

  inline LedRequest& operator=(const LedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LedRequest& operator=(LedRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LedRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LedRequest* internal_default_instance() {
    return reinterpret_cast<const LedRequest*>(
               &_LedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LedRequest& a, LedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LedRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LedRequest* New() const final {
    return CreateMaybeMessage<LedRequest>(nullptr);
  }

  LedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LedRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LedRequest& from);
  void MergeFrom(const LedRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LedRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.LedRequest";
  }
  protected:
  explicit LedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOnFieldNumber = 1,
    kOffFieldNumber = 2,
  };
  // uint32 on = 1;
  void clear_on();
  ::PROTOBUF_NAMESPACE_ID::uint32 on() const;
  void set_on(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_on() const;
  void _internal_set_on(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 off = 2;
  void clear_off();
  ::PROTOBUF_NAMESPACE_ID::uint32 off() const;
  void set_off(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_off() const;
  void _internal_set_off(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.LedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 on_;
  ::PROTOBUF_NAMESPACE_ID::uint32 off_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class TtsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.TtsRequest) */ {
 public:
  inline TtsRequest() : TtsRequest(nullptr) {};
  virtual ~TtsRequest();

  TtsRequest(const TtsRequest& from);
  TtsRequest(TtsRequest&& from) noexcept
    : TtsRequest() {
    *this = ::std::move(from);
  }

  inline TtsRequest& operator=(const TtsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TtsRequest& operator=(TtsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TtsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TtsRequest* internal_default_instance() {
    return reinterpret_cast<const TtsRequest*>(
               &_TtsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TtsRequest& a, TtsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TtsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TtsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TtsRequest* New() const final {
    return CreateMaybeMessage<TtsRequest>(nullptr);
  }

  TtsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TtsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TtsRequest& from);
  void MergeFrom(const TtsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TtsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.TtsRequest";
  }
  protected:
  explicit TtsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TtsRequest_Locale Locale;
  static constexpr Locale English =
    TtsRequest_Locale_English;
  static constexpr Locale Chinese =
    TtsRequest_Locale_Chinese;
  static inline bool Locale_IsValid(int value) {
    return TtsRequest_Locale_IsValid(value);
  }
  static constexpr Locale Locale_MIN =
    TtsRequest_Locale_Locale_MIN;
  static constexpr Locale Locale_MAX =
    TtsRequest_Locale_Locale_MAX;
  static constexpr int Locale_ARRAYSIZE =
    TtsRequest_Locale_Locale_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Locale_descriptor() {
    return TtsRequest_Locale_descriptor();
  }
  template<typename T>
  static inline const std::string& Locale_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Locale>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Locale_Name.");
    return TtsRequest_Locale_Name(enum_t_value);
  }
  static inline bool Locale_Parse(const std::string& name,
      Locale* value) {
    return TtsRequest_Locale_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kIntervalFieldNumber = 1,
    kTimesFieldNumber = 2,
    kLocaleFieldNumber = 4,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint32 interval = 1;
  void clear_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 interval() const;
  void set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_interval() const;
  void _internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 times = 2;
  void clear_times();
  ::PROTOBUF_NAMESPACE_ID::uint32 times() const;
  void set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_times() const;
  void _internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // .ashoka.hardware.TtsRequest.Locale locale = 4;
  void clear_locale();
  ::ashoka::hardware::TtsRequest_Locale locale() const;
  void set_locale(::ashoka::hardware::TtsRequest_Locale value);
  private:
  ::ashoka::hardware::TtsRequest_Locale _internal_locale() const;
  void _internal_set_locale(::ashoka::hardware::TtsRequest_Locale value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.TtsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint32 interval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 times_;
  int locale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class Audio_Stream PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.Audio.Stream) */ {
 public:
  inline Audio_Stream() : Audio_Stream(nullptr) {};
  virtual ~Audio_Stream();

  Audio_Stream(const Audio_Stream& from);
  Audio_Stream(Audio_Stream&& from) noexcept
    : Audio_Stream() {
    *this = ::std::move(from);
  }

  inline Audio_Stream& operator=(const Audio_Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline Audio_Stream& operator=(Audio_Stream&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Audio_Stream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Audio_Stream* internal_default_instance() {
    return reinterpret_cast<const Audio_Stream*>(
               &_Audio_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Audio_Stream& a, Audio_Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(Audio_Stream* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Audio_Stream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Audio_Stream* New() const final {
    return CreateMaybeMessage<Audio_Stream>(nullptr);
  }

  Audio_Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Audio_Stream>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Audio_Stream& from);
  void MergeFrom(const Audio_Stream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Audio_Stream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.Audio.Stream";
  }
  protected:
  explicit Audio_Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Audio_Stream_Type Type;
  static constexpr Type WAV =
    Audio_Stream_Type_WAV;
  static constexpr Type MP3 =
    Audio_Stream_Type_MP3;
  static inline bool Type_IsValid(int value) {
    return Audio_Stream_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Audio_Stream_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Audio_Stream_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Audio_Stream_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Audio_Stream_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Audio_Stream_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return Audio_Stream_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kOrderFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  void set_payload(const std::string& value);
  void set_payload(std::string&& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  std::string* mutable_payload();
  std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_payload();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_payload(
      std::string* payload);
  private:
  const std::string& _internal_payload() const;
  void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // int32 order = 1;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::int32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_order() const;
  void _internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .ashoka.hardware.Audio.Stream.Type type = 2;
  void clear_type();
  ::ashoka::hardware::Audio_Stream_Type type() const;
  void set_type(::ashoka::hardware::Audio_Stream_Type value);
  private:
  ::ashoka::hardware::Audio_Stream_Type _internal_type() const;
  void _internal_set_type(::ashoka::hardware::Audio_Stream_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.Audio.Stream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::int32 order_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class Audio_File PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.Audio.File) */ {
 public:
  inline Audio_File() : Audio_File(nullptr) {};
  virtual ~Audio_File();

  Audio_File(const Audio_File& from);
  Audio_File(Audio_File&& from) noexcept
    : Audio_File() {
    *this = ::std::move(from);
  }

  inline Audio_File& operator=(const Audio_File& from) {
    CopyFrom(from);
    return *this;
  }
  inline Audio_File& operator=(Audio_File&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Audio_File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Audio_File* internal_default_instance() {
    return reinterpret_cast<const Audio_File*>(
               &_Audio_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Audio_File& a, Audio_File& b) {
    a.Swap(&b);
  }
  inline void Swap(Audio_File* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Audio_File* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Audio_File* New() const final {
    return CreateMaybeMessage<Audio_File>(nullptr);
  }

  Audio_File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Audio_File>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Audio_File& from);
  void MergeFrom(const Audio_File& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Audio_File* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.Audio.File";
  }
  protected:
  explicit Audio_File(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kOrderFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 order = 1;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::int32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_order() const;
  void _internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.Audio.File)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class Audio PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.Audio) */ {
 public:
  inline Audio() : Audio(nullptr) {};
  virtual ~Audio();

  Audio(const Audio& from);
  Audio(Audio&& from) noexcept
    : Audio() {
    *this = ::std::move(from);
  }

  inline Audio& operator=(const Audio& from) {
    CopyFrom(from);
    return *this;
  }
  inline Audio& operator=(Audio&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Audio& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Audio* internal_default_instance() {
    return reinterpret_cast<const Audio*>(
               &_Audio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Audio& a, Audio& b) {
    a.Swap(&b);
  }
  inline void Swap(Audio* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Audio* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Audio* New() const final {
    return CreateMaybeMessage<Audio>(nullptr);
  }

  Audio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Audio>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Audio& from);
  void MergeFrom(const Audio& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Audio* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.Audio";
  }
  protected:
  explicit Audio(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Audio_Stream Stream;
  typedef Audio_File File;

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 3,
    kStreamsFieldNumber = 4,
    kIntervalFieldNumber = 1,
    kTimesFieldNumber = 2,
  };
  // repeated .ashoka.hardware.Audio.File files = 3;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::ashoka::hardware::Audio_File* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Audio_File >*
      mutable_files();
  private:
  const ::ashoka::hardware::Audio_File& _internal_files(int index) const;
  ::ashoka::hardware::Audio_File* _internal_add_files();
  public:
  const ::ashoka::hardware::Audio_File& files(int index) const;
  ::ashoka::hardware::Audio_File* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Audio_File >&
      files() const;

  // repeated .ashoka.hardware.Audio.Stream streams = 4;
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  ::ashoka::hardware::Audio_Stream* mutable_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Audio_Stream >*
      mutable_streams();
  private:
  const ::ashoka::hardware::Audio_Stream& _internal_streams(int index) const;
  ::ashoka::hardware::Audio_Stream* _internal_add_streams();
  public:
  const ::ashoka::hardware::Audio_Stream& streams(int index) const;
  ::ashoka::hardware::Audio_Stream* add_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Audio_Stream >&
      streams() const;

  // uint32 interval = 1;
  void clear_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 interval() const;
  void set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_interval() const;
  void _internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 times = 2;
  void clear_times();
  ::PROTOBUF_NAMESPACE_ID::uint32 times() const;
  void set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_times() const;
  void _internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.Audio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Audio_File > files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Audio_Stream > streams_;
  ::PROTOBUF_NAMESPACE_ID::uint32 interval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 times_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class Video_Stream PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.Video.Stream) */ {
 public:
  inline Video_Stream() : Video_Stream(nullptr) {};
  virtual ~Video_Stream();

  Video_Stream(const Video_Stream& from);
  Video_Stream(Video_Stream&& from) noexcept
    : Video_Stream() {
    *this = ::std::move(from);
  }

  inline Video_Stream& operator=(const Video_Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline Video_Stream& operator=(Video_Stream&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Video_Stream& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Video_Stream* internal_default_instance() {
    return reinterpret_cast<const Video_Stream*>(
               &_Video_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Video_Stream& a, Video_Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(Video_Stream* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Video_Stream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Video_Stream* New() const final {
    return CreateMaybeMessage<Video_Stream>(nullptr);
  }

  Video_Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Video_Stream>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Video_Stream& from);
  void MergeFrom(const Video_Stream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Video_Stream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.Video.Stream";
  }
  protected:
  explicit Video_Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Video_Stream_Type Type;
  static constexpr Type MP4 =
    Video_Stream_Type_MP4;
  static inline bool Type_IsValid(int value) {
    return Video_Stream_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Video_Stream_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Video_Stream_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Video_Stream_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Video_Stream_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Video_Stream_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return Video_Stream_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 3,
    kOrderFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // bytes payload = 3;
  void clear_payload();
  const std::string& payload() const;
  void set_payload(const std::string& value);
  void set_payload(std::string&& value);
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  std::string* mutable_payload();
  std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_payload();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_payload(
      std::string* payload);
  private:
  const std::string& _internal_payload() const;
  void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // int32 order = 1;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::int32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_order() const;
  void _internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .ashoka.hardware.Video.Stream.Type type = 2;
  void clear_type();
  ::ashoka::hardware::Video_Stream_Type type() const;
  void set_type(::ashoka::hardware::Video_Stream_Type value);
  private:
  ::ashoka::hardware::Video_Stream_Type _internal_type() const;
  void _internal_set_type(::ashoka::hardware::Video_Stream_Type value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.Video.Stream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::int32 order_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class Video_File PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.Video.File) */ {
 public:
  inline Video_File() : Video_File(nullptr) {};
  virtual ~Video_File();

  Video_File(const Video_File& from);
  Video_File(Video_File&& from) noexcept
    : Video_File() {
    *this = ::std::move(from);
  }

  inline Video_File& operator=(const Video_File& from) {
    CopyFrom(from);
    return *this;
  }
  inline Video_File& operator=(Video_File&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Video_File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Video_File* internal_default_instance() {
    return reinterpret_cast<const Video_File*>(
               &_Video_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Video_File& a, Video_File& b) {
    a.Swap(&b);
  }
  inline void Swap(Video_File* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Video_File* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Video_File* New() const final {
    return CreateMaybeMessage<Video_File>(nullptr);
  }

  Video_File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Video_File>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Video_File& from);
  void MergeFrom(const Video_File& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Video_File* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.Video.File";
  }
  protected:
  explicit Video_File(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kOrderFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_path(
      std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 order = 1;
  void clear_order();
  ::PROTOBUF_NAMESPACE_ID::int32 order() const;
  void set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_order() const;
  void _internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.Video.File)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::int32 order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// -------------------------------------------------------------------

class Video PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ashoka.hardware.Video) */ {
 public:
  inline Video() : Video(nullptr) {};
  virtual ~Video();

  Video(const Video& from);
  Video(Video&& from) noexcept
    : Video() {
    *this = ::std::move(from);
  }

  inline Video& operator=(const Video& from) {
    CopyFrom(from);
    return *this;
  }
  inline Video& operator=(Video&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Video& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Video* internal_default_instance() {
    return reinterpret_cast<const Video*>(
               &_Video_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Video& a, Video& b) {
    a.Swap(&b);
  }
  inline void Swap(Video* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Video* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Video* New() const final {
    return CreateMaybeMessage<Video>(nullptr);
  }

  Video* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Video>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Video& from);
  void MergeFrom(const Video& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Video* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ashoka.hardware.Video";
  }
  protected:
  explicit Video(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hardware_2eproto);
    return ::descriptor_table_hardware_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Video_Stream Stream;
  typedef Video_File File;

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 3,
    kStreamsFieldNumber = 4,
    kIntervalFieldNumber = 1,
    kTimesFieldNumber = 2,
  };
  // repeated .ashoka.hardware.Video.File files = 3;
  int files_size() const;
  private:
  int _internal_files_size() const;
  public:
  void clear_files();
  ::ashoka::hardware::Video_File* mutable_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Video_File >*
      mutable_files();
  private:
  const ::ashoka::hardware::Video_File& _internal_files(int index) const;
  ::ashoka::hardware::Video_File* _internal_add_files();
  public:
  const ::ashoka::hardware::Video_File& files(int index) const;
  ::ashoka::hardware::Video_File* add_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Video_File >&
      files() const;

  // repeated .ashoka.hardware.Video.Stream streams = 4;
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  ::ashoka::hardware::Video_Stream* mutable_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Video_Stream >*
      mutable_streams();
  private:
  const ::ashoka::hardware::Video_Stream& _internal_streams(int index) const;
  ::ashoka::hardware::Video_Stream* _internal_add_streams();
  public:
  const ::ashoka::hardware::Video_Stream& streams(int index) const;
  ::ashoka::hardware::Video_Stream* add_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Video_Stream >&
      streams() const;

  // uint32 interval = 1;
  void clear_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 interval() const;
  void set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_interval() const;
  void _internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 times = 2;
  void clear_times();
  ::PROTOBUF_NAMESPACE_ID::uint32 times() const;
  void set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_times() const;
  void _internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ashoka.hardware.Video)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Video_File > files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Video_Stream > streams_;
  ::PROTOBUF_NAMESPACE_ID::uint32 interval_;
  ::PROTOBUF_NAMESPACE_ID::uint32 times_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hardware_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Response

// bool ok = 1;
inline void Response::clear_ok() {
  ok_ = false;
}
inline bool Response::_internal_ok() const {
  return ok_;
}
inline bool Response::ok() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Response.ok)
  return _internal_ok();
}
inline void Response::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void Response::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Response.ok)
}

// uint64 timestamp = 2;
inline void Response::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Response::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Response::timestamp() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Response.timestamp)
  return _internal_timestamp();
}
inline void Response::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void Response::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Response.timestamp)
}

// repeated string messages = 3;
inline int Response::_internal_messages_size() const {
  return messages_.size();
}
inline int Response::messages_size() const {
  return _internal_messages_size();
}
inline void Response::clear_messages() {
  messages_.Clear();
}
inline std::string* Response::add_messages() {
  // @@protoc_insertion_point(field_add_mutable:ashoka.hardware.Response.messages)
  return _internal_add_messages();
}
inline const std::string& Response::_internal_messages(int index) const {
  return messages_.Get(index);
}
inline const std::string& Response::messages(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Response.messages)
  return _internal_messages(index);
}
inline std::string* Response::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Response.messages)
  return messages_.Mutable(index);
}
inline void Response::set_messages(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:ashoka.hardware.Response.messages)
  messages_.Mutable(index)->assign(value);
}
inline void Response::set_messages(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:ashoka.hardware.Response.messages)
  messages_.Mutable(index)->assign(std::move(value));
}
inline void Response::set_messages(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  messages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.Response.messages)
}
inline void Response::set_messages(int index, const char* value, size_t size) {
  messages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.Response.messages)
}
inline std::string* Response::_internal_add_messages() {
  return messages_.Add();
}
inline void Response::add_messages(const std::string& value) {
  messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ashoka.hardware.Response.messages)
}
inline void Response::add_messages(std::string&& value) {
  messages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ashoka.hardware.Response.messages)
}
inline void Response::add_messages(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  messages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ashoka.hardware.Response.messages)
}
inline void Response::add_messages(const char* value, size_t size) {
  messages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ashoka.hardware.Response.messages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Response::messages() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.Response.messages)
  return messages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Response::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.Response.messages)
  return &messages_;
}

// -------------------------------------------------------------------

// TtyRequest

// string command = 1;
inline void TtyRequest::clear_command() {
  command_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TtyRequest::command() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtyRequest.command)
  return _internal_command();
}
inline void TtyRequest::set_command(const std::string& value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtyRequest.command)
}
inline std::string* TtyRequest::mutable_command() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.TtyRequest.command)
  return _internal_mutable_command();
}
inline const std::string& TtyRequest::_internal_command() const {
  return command_.Get();
}
inline void TtyRequest::_internal_set_command(const std::string& value) {
  
  command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TtyRequest::set_command(std::string&& value) {
  
  command_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.TtyRequest.command)
}
inline void TtyRequest::set_command(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.TtyRequest.command)
}
inline void TtyRequest::set_command(const char* value,
    size_t size) {
  
  command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.TtyRequest.command)
}
inline std::string* TtyRequest::_internal_mutable_command() {
  
  return command_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TtyRequest::release_command() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.TtyRequest.command)
  return command_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TtyRequest::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  command_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), command,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.TtyRequest.command)
}
inline std::string* TtyRequest::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ashoka.hardware.TtyRequest.command)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return command_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TtyRequest::unsafe_arena_set_allocated_command(
    std::string* command) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (command != nullptr) {
    
  } else {
    
  }
  command_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      command, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ashoka.hardware.TtyRequest.command)
}

// -------------------------------------------------------------------

// TtyResponse

// string message = 1;
inline void TtyResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TtyResponse::message() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtyResponse.message)
  return _internal_message();
}
inline void TtyResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtyResponse.message)
}
inline std::string* TtyResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.TtyResponse.message)
  return _internal_mutable_message();
}
inline const std::string& TtyResponse::_internal_message() const {
  return message_.Get();
}
inline void TtyResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TtyResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.TtyResponse.message)
}
inline void TtyResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.TtyResponse.message)
}
inline void TtyResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.TtyResponse.message)
}
inline std::string* TtyResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TtyResponse::release_message() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.TtyResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TtyResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.TtyResponse.message)
}
inline std::string* TtyResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ashoka.hardware.TtyResponse.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TtyResponse::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ashoka.hardware.TtyResponse.message)
}

// uint64 timestamp = 2;
inline void TtyResponse::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TtyResponse::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TtyResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtyResponse.timestamp)
  return _internal_timestamp();
}
inline void TtyResponse::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void TtyResponse::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtyResponse.timestamp)
}

// -------------------------------------------------------------------

// LedRequest

// uint32 on = 1;
inline void LedRequest::clear_on() {
  on_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LedRequest::_internal_on() const {
  return on_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LedRequest::on() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.LedRequest.on)
  return _internal_on();
}
inline void LedRequest::_internal_set_on(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  on_ = value;
}
inline void LedRequest::set_on(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_on(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.LedRequest.on)
}

// uint32 off = 2;
inline void LedRequest::clear_off() {
  off_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LedRequest::_internal_off() const {
  return off_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LedRequest::off() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.LedRequest.off)
  return _internal_off();
}
inline void LedRequest::_internal_set_off(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  off_ = value;
}
inline void LedRequest::set_off(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_off(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.LedRequest.off)
}

// -------------------------------------------------------------------

// TtsRequest

// uint32 interval = 1;
inline void TtsRequest::clear_interval() {
  interval_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TtsRequest::_internal_interval() const {
  return interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TtsRequest::interval() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtsRequest.interval)
  return _internal_interval();
}
inline void TtsRequest::_internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  interval_ = value;
}
inline void TtsRequest::set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtsRequest.interval)
}

// uint32 times = 2;
inline void TtsRequest::clear_times() {
  times_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TtsRequest::_internal_times() const {
  return times_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TtsRequest::times() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtsRequest.times)
  return _internal_times();
}
inline void TtsRequest::_internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  times_ = value;
}
inline void TtsRequest::set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_times(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtsRequest.times)
}

// string message = 3;
inline void TtsRequest::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& TtsRequest::message() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtsRequest.message)
  return _internal_message();
}
inline void TtsRequest::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtsRequest.message)
}
inline std::string* TtsRequest::mutable_message() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.TtsRequest.message)
  return _internal_mutable_message();
}
inline const std::string& TtsRequest::_internal_message() const {
  return message_.Get();
}
inline void TtsRequest::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TtsRequest::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.TtsRequest.message)
}
inline void TtsRequest::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.TtsRequest.message)
}
inline void TtsRequest::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.TtsRequest.message)
}
inline std::string* TtsRequest::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TtsRequest::release_message() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.TtsRequest.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TtsRequest::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.TtsRequest.message)
}
inline std::string* TtsRequest::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ashoka.hardware.TtsRequest.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TtsRequest::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ashoka.hardware.TtsRequest.message)
}

// .ashoka.hardware.TtsRequest.Locale locale = 4;
inline void TtsRequest::clear_locale() {
  locale_ = 0;
}
inline ::ashoka::hardware::TtsRequest_Locale TtsRequest::_internal_locale() const {
  return static_cast< ::ashoka::hardware::TtsRequest_Locale >(locale_);
}
inline ::ashoka::hardware::TtsRequest_Locale TtsRequest::locale() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.TtsRequest.locale)
  return _internal_locale();
}
inline void TtsRequest::_internal_set_locale(::ashoka::hardware::TtsRequest_Locale value) {
  
  locale_ = value;
}
inline void TtsRequest::set_locale(::ashoka::hardware::TtsRequest_Locale value) {
  _internal_set_locale(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.TtsRequest.locale)
}

// -------------------------------------------------------------------

// Audio_Stream

// int32 order = 1;
inline void Audio_Stream::clear_order() {
  order_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Audio_Stream::_internal_order() const {
  return order_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Audio_Stream::order() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Audio.Stream.order)
  return _internal_order();
}
inline void Audio_Stream::_internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  order_ = value;
}
inline void Audio_Stream::set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Audio.Stream.order)
}

// .ashoka.hardware.Audio.Stream.Type type = 2;
inline void Audio_Stream::clear_type() {
  type_ = 0;
}
inline ::ashoka::hardware::Audio_Stream_Type Audio_Stream::_internal_type() const {
  return static_cast< ::ashoka::hardware::Audio_Stream_Type >(type_);
}
inline ::ashoka::hardware::Audio_Stream_Type Audio_Stream::type() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Audio.Stream.type)
  return _internal_type();
}
inline void Audio_Stream::_internal_set_type(::ashoka::hardware::Audio_Stream_Type value) {
  
  type_ = value;
}
inline void Audio_Stream::set_type(::ashoka::hardware::Audio_Stream_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Audio.Stream.type)
}

// bytes payload = 3;
inline void Audio_Stream::clear_payload() {
  payload_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Audio_Stream::payload() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Audio.Stream.payload)
  return _internal_payload();
}
inline void Audio_Stream::set_payload(const std::string& value) {
  _internal_set_payload(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Audio.Stream.payload)
}
inline std::string* Audio_Stream::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Audio.Stream.payload)
  return _internal_mutable_payload();
}
inline const std::string& Audio_Stream::_internal_payload() const {
  return payload_.Get();
}
inline void Audio_Stream::_internal_set_payload(const std::string& value) {
  
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Audio_Stream::set_payload(std::string&& value) {
  
  payload_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.Audio.Stream.payload)
}
inline void Audio_Stream::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.Audio.Stream.payload)
}
inline void Audio_Stream::set_payload(const void* value,
    size_t size) {
  
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.Audio.Stream.payload)
}
inline std::string* Audio_Stream::_internal_mutable_payload() {
  
  return payload_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Audio_Stream::release_payload() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Audio.Stream.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Audio_Stream::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.Audio.Stream.payload)
}
inline std::string* Audio_Stream::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ashoka.hardware.Audio.Stream.payload)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return payload_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Audio_Stream::unsafe_arena_set_allocated_payload(
    std::string* payload) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      payload, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ashoka.hardware.Audio.Stream.payload)
}

// -------------------------------------------------------------------

// Audio_File

// int32 order = 1;
inline void Audio_File::clear_order() {
  order_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Audio_File::_internal_order() const {
  return order_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Audio_File::order() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Audio.File.order)
  return _internal_order();
}
inline void Audio_File::_internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  order_ = value;
}
inline void Audio_File::set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Audio.File.order)
}

// string path = 2;
inline void Audio_File::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Audio_File::path() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Audio.File.path)
  return _internal_path();
}
inline void Audio_File::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Audio.File.path)
}
inline std::string* Audio_File::mutable_path() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Audio.File.path)
  return _internal_mutable_path();
}
inline const std::string& Audio_File::_internal_path() const {
  return path_.Get();
}
inline void Audio_File::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Audio_File::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.Audio.File.path)
}
inline void Audio_File::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.Audio.File.path)
}
inline void Audio_File::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.Audio.File.path)
}
inline std::string* Audio_File::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Audio_File::release_path() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Audio.File.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Audio_File::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.Audio.File.path)
}
inline std::string* Audio_File::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ashoka.hardware.Audio.File.path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Audio_File::unsafe_arena_set_allocated_path(
    std::string* path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (path != nullptr) {
    
  } else {
    
  }
  path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ashoka.hardware.Audio.File.path)
}

// -------------------------------------------------------------------

// Audio

// uint32 interval = 1;
inline void Audio::clear_interval() {
  interval_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Audio::_internal_interval() const {
  return interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Audio::interval() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Audio.interval)
  return _internal_interval();
}
inline void Audio::_internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  interval_ = value;
}
inline void Audio::set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Audio.interval)
}

// uint32 times = 2;
inline void Audio::clear_times() {
  times_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Audio::_internal_times() const {
  return times_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Audio::times() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Audio.times)
  return _internal_times();
}
inline void Audio::_internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  times_ = value;
}
inline void Audio::set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_times(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Audio.times)
}

// repeated .ashoka.hardware.Audio.File files = 3;
inline int Audio::_internal_files_size() const {
  return files_.size();
}
inline int Audio::files_size() const {
  return _internal_files_size();
}
inline void Audio::clear_files() {
  files_.Clear();
}
inline ::ashoka::hardware::Audio_File* Audio::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Audio.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Audio_File >*
Audio::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.Audio.files)
  return &files_;
}
inline const ::ashoka::hardware::Audio_File& Audio::_internal_files(int index) const {
  return files_.Get(index);
}
inline const ::ashoka::hardware::Audio_File& Audio::files(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Audio.files)
  return _internal_files(index);
}
inline ::ashoka::hardware::Audio_File* Audio::_internal_add_files() {
  return files_.Add();
}
inline ::ashoka::hardware::Audio_File* Audio::add_files() {
  // @@protoc_insertion_point(field_add:ashoka.hardware.Audio.files)
  return _internal_add_files();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Audio_File >&
Audio::files() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.Audio.files)
  return files_;
}

// repeated .ashoka.hardware.Audio.Stream streams = 4;
inline int Audio::_internal_streams_size() const {
  return streams_.size();
}
inline int Audio::streams_size() const {
  return _internal_streams_size();
}
inline void Audio::clear_streams() {
  streams_.Clear();
}
inline ::ashoka::hardware::Audio_Stream* Audio::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Audio.streams)
  return streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Audio_Stream >*
Audio::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.Audio.streams)
  return &streams_;
}
inline const ::ashoka::hardware::Audio_Stream& Audio::_internal_streams(int index) const {
  return streams_.Get(index);
}
inline const ::ashoka::hardware::Audio_Stream& Audio::streams(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Audio.streams)
  return _internal_streams(index);
}
inline ::ashoka::hardware::Audio_Stream* Audio::_internal_add_streams() {
  return streams_.Add();
}
inline ::ashoka::hardware::Audio_Stream* Audio::add_streams() {
  // @@protoc_insertion_point(field_add:ashoka.hardware.Audio.streams)
  return _internal_add_streams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Audio_Stream >&
Audio::streams() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.Audio.streams)
  return streams_;
}

// -------------------------------------------------------------------

// Video_Stream

// int32 order = 1;
inline void Video_Stream::clear_order() {
  order_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Video_Stream::_internal_order() const {
  return order_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Video_Stream::order() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Video.Stream.order)
  return _internal_order();
}
inline void Video_Stream::_internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  order_ = value;
}
inline void Video_Stream::set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Video.Stream.order)
}

// .ashoka.hardware.Video.Stream.Type type = 2;
inline void Video_Stream::clear_type() {
  type_ = 0;
}
inline ::ashoka::hardware::Video_Stream_Type Video_Stream::_internal_type() const {
  return static_cast< ::ashoka::hardware::Video_Stream_Type >(type_);
}
inline ::ashoka::hardware::Video_Stream_Type Video_Stream::type() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Video.Stream.type)
  return _internal_type();
}
inline void Video_Stream::_internal_set_type(::ashoka::hardware::Video_Stream_Type value) {
  
  type_ = value;
}
inline void Video_Stream::set_type(::ashoka::hardware::Video_Stream_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Video.Stream.type)
}

// bytes payload = 3;
inline void Video_Stream::clear_payload() {
  payload_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Video_Stream::payload() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Video.Stream.payload)
  return _internal_payload();
}
inline void Video_Stream::set_payload(const std::string& value) {
  _internal_set_payload(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Video.Stream.payload)
}
inline std::string* Video_Stream::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Video.Stream.payload)
  return _internal_mutable_payload();
}
inline const std::string& Video_Stream::_internal_payload() const {
  return payload_.Get();
}
inline void Video_Stream::_internal_set_payload(const std::string& value) {
  
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Video_Stream::set_payload(std::string&& value) {
  
  payload_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.Video.Stream.payload)
}
inline void Video_Stream::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.Video.Stream.payload)
}
inline void Video_Stream::set_payload(const void* value,
    size_t size) {
  
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.Video.Stream.payload)
}
inline std::string* Video_Stream::_internal_mutable_payload() {
  
  return payload_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Video_Stream::release_payload() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Video.Stream.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Video_Stream::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.Video.Stream.payload)
}
inline std::string* Video_Stream::unsafe_arena_release_payload() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ashoka.hardware.Video.Stream.payload)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return payload_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Video_Stream::unsafe_arena_set_allocated_payload(
    std::string* payload) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      payload, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ashoka.hardware.Video.Stream.payload)
}

// -------------------------------------------------------------------

// Video_File

// int32 order = 1;
inline void Video_File::clear_order() {
  order_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Video_File::_internal_order() const {
  return order_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Video_File::order() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Video.File.order)
  return _internal_order();
}
inline void Video_File::_internal_set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  order_ = value;
}
inline void Video_File::set_order(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Video.File.order)
}

// string path = 2;
inline void Video_File::clear_path() {
  path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Video_File::path() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Video.File.path)
  return _internal_path();
}
inline void Video_File::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Video.File.path)
}
inline std::string* Video_File::mutable_path() {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Video.File.path)
  return _internal_mutable_path();
}
inline const std::string& Video_File::_internal_path() const {
  return path_.Get();
}
inline void Video_File::_internal_set_path(const std::string& value) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Video_File::set_path(std::string&& value) {
  
  path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ashoka.hardware.Video.File.path)
}
inline void Video_File::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ashoka.hardware.Video.File.path)
}
inline void Video_File::set_path(const char* value,
    size_t size) {
  
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ashoka.hardware.Video.File.path)
}
inline std::string* Video_File::_internal_mutable_path() {
  
  return path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Video_File::release_path() {
  // @@protoc_insertion_point(field_release:ashoka.hardware.Video.File.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Video_File::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ashoka.hardware.Video.File.path)
}
inline std::string* Video_File::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ashoka.hardware.Video.File.path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Video_File::unsafe_arena_set_allocated_path(
    std::string* path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (path != nullptr) {
    
  } else {
    
  }
  path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ashoka.hardware.Video.File.path)
}

// -------------------------------------------------------------------

// Video

// uint32 interval = 1;
inline void Video::clear_interval() {
  interval_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Video::_internal_interval() const {
  return interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Video::interval() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Video.interval)
  return _internal_interval();
}
inline void Video::_internal_set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  interval_ = value;
}
inline void Video::set_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Video.interval)
}

// uint32 times = 2;
inline void Video::clear_times() {
  times_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Video::_internal_times() const {
  return times_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Video::times() const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Video.times)
  return _internal_times();
}
inline void Video::_internal_set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  times_ = value;
}
inline void Video::set_times(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_times(value);
  // @@protoc_insertion_point(field_set:ashoka.hardware.Video.times)
}

// repeated .ashoka.hardware.Video.File files = 3;
inline int Video::_internal_files_size() const {
  return files_.size();
}
inline int Video::files_size() const {
  return _internal_files_size();
}
inline void Video::clear_files() {
  files_.Clear();
}
inline ::ashoka::hardware::Video_File* Video::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Video.files)
  return files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Video_File >*
Video::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.Video.files)
  return &files_;
}
inline const ::ashoka::hardware::Video_File& Video::_internal_files(int index) const {
  return files_.Get(index);
}
inline const ::ashoka::hardware::Video_File& Video::files(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Video.files)
  return _internal_files(index);
}
inline ::ashoka::hardware::Video_File* Video::_internal_add_files() {
  return files_.Add();
}
inline ::ashoka::hardware::Video_File* Video::add_files() {
  // @@protoc_insertion_point(field_add:ashoka.hardware.Video.files)
  return _internal_add_files();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Video_File >&
Video::files() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.Video.files)
  return files_;
}

// repeated .ashoka.hardware.Video.Stream streams = 4;
inline int Video::_internal_streams_size() const {
  return streams_.size();
}
inline int Video::streams_size() const {
  return _internal_streams_size();
}
inline void Video::clear_streams() {
  streams_.Clear();
}
inline ::ashoka::hardware::Video_Stream* Video::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:ashoka.hardware.Video.streams)
  return streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Video_Stream >*
Video::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:ashoka.hardware.Video.streams)
  return &streams_;
}
inline const ::ashoka::hardware::Video_Stream& Video::_internal_streams(int index) const {
  return streams_.Get(index);
}
inline const ::ashoka::hardware::Video_Stream& Video::streams(int index) const {
  // @@protoc_insertion_point(field_get:ashoka.hardware.Video.streams)
  return _internal_streams(index);
}
inline ::ashoka::hardware::Video_Stream* Video::_internal_add_streams() {
  return streams_.Add();
}
inline ::ashoka::hardware::Video_Stream* Video::add_streams() {
  // @@protoc_insertion_point(field_add:ashoka.hardware.Video.streams)
  return _internal_add_streams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ashoka::hardware::Video_Stream >&
Video::streams() const {
  // @@protoc_insertion_point(field_list:ashoka.hardware.Video.streams)
  return streams_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hardware
}  // namespace ashoka

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ashoka::hardware::TtsRequest_Locale> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ashoka::hardware::TtsRequest_Locale>() {
  return ::ashoka::hardware::TtsRequest_Locale_descriptor();
}
template <> struct is_proto_enum< ::ashoka::hardware::Audio_Stream_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ashoka::hardware::Audio_Stream_Type>() {
  return ::ashoka::hardware::Audio_Stream_Type_descriptor();
}
template <> struct is_proto_enum< ::ashoka::hardware::Video_Stream_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ashoka::hardware::Video_Stream_Type>() {
  return ::ashoka::hardware::Video_Stream_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hardware_2eproto
